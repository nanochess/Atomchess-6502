------- FILE toledo_atomchess_6502.asm LEVEL 1 PASS 2
      1  10000 ????						;
      2  10000 ????						; Toledo Atomchess 6502 for Atari VCS/2600
      3  10000 ????						;
      4  10000 ????						; by Óscar Toledo G. (nanochess)
      5  10000 ????						;
      6  10000 ????						; © Copyright 2017 Óscar Toledo Gutiérrez
      7  10000 ????						;
      8  10000 ????						; Creation date: Jan/02/2017. Ported from Toledo Atomchess x86.
      9  10000 ????						; Revision date: Jan/04/2017. Working board display logic and selection.
     10  10000 ????						; Revision date: Jan/05/2017. Avoid player to move non-white pieces or
     11  10000 ????						;			       bug when fire bounces. Now using another
     12  10000 ????						;			       color for black pieces. Small optimization.
     13  10000 ????						; Revision date: Jan/13/2017. Solved bug where it would answer with move
     14  10000 ????						;			       after checkmate. Some more comments.
     15  10000 ????						; Revision date: Jan/15/2017. Added size optimizations by Peter Ferrie,
     16  10000 ????						;			       19 bytes saved. Also I've optimized my
     17  10000 ????						;			       graphical/input interface for further 18
     18  10000 ????						;			       bytes.
     19  10000 ????						; Revision date: Jan/16/2017. Saved 2 bytes more in playfield setup for
     20  10000 ????						;			       squares (Ferrie). Taken note of which
     21  10000 ????						;			       instructions can trigger the oVerflow flag.
     22  10000 ????						;			       Now can be assembled for visual6502.org
     23  10000 ????						; Revision date: Jul/08/2017. Redesigned display code to use venetian blinds
     24  10000 ????						;			       technique in Atari VCS display, it allows for
     25  10000 ????						;			       30hz flicker so pieces will look steady. Now
     26  10000 ????						;			       cursor can turn around the chessboard and also
     27  10000 ????						;			       saves bytes. Support for Supercharger.
     28  10000 ????						;
     29  10000 ????
     30  10000 ????				       processor	6502
     31  10000 ????
     32  10000 ????		00 00	    atari      =	$00	; Define this to create an Atari VCS/2600 game (1K ROM)
     33  10000 ????		00 01	    visual6502 =	$01	; Define this to create a Visual6502.org playable game.
     34  10000 ????
     35  10000 ????						;
     36  10000 ????						; Change this to your preference.
     37  10000 ????						;
     38  10000 ????		00 00	    mode       =	atari
     39  10000 ????
     40  10000 ????						; Features:
     41  10000 ????						; * Computer plays legal basic chess movements ;)
     42  10000 ????						; * Move with joystick, push button to select, push button to drop.
     43  10000 ????						; * Search depth of 2-ply
     44  10000 ????						; * Promotion of pawns only to queen.
     45  10000 ????						; * No castling
     46  10000 ????						; * No en passant.
     47  10000 ????						; * 1K self-contained size for Hackaday
     48  10000 ????						;
     49  10000 ????						; Assemble with dasm from http://dasm-dillon.sourceforge.net/ 
     50  10000 ????						; Tested with Stella from http://stella.sourceforge.net/
     51  10000 ????						; Tested in real Atari 2600 using Harmony cartridge.
     52  10000 ????						; Tested with online emulation from http://8bitworkshop.com/
     53  10000 ????						; Demostration video at https://www.youtube.com/watch?v=_Du4krvIl7o
     54  10000 ????
     55  10000 ????				       if	mode = atari
     56  10000 ????
     57  fc00					      org	$fc00
     58  fc00		       00 00	   VSYNC      =	$00	; 0000 00x0   Vertical Sync Set-Clear
     59  fc00		       00 01	   VBLANK     =	$01	; xx00 00x0   Vertical Blank Set-Clear
     60  fc00		       00 02	   WSYNC      =	$02	; ---- ----   Wait for Horizontal Blank
     61  fc00		       00 03	   RSYNC      =	$03	; ---- ----   Reset Horizontal Sync Counter
     62  fc00		       00 04	   NUSIZ0     =	$04	; 00xx 0xxx   Number-Size player/missile 0
     63  fc00		       00 05	   NUSIZ1     =	$05	; 00xx 0xxx   Number-Size player/missile 1
     64  fc00		       00 06	   COLUP0     =	$06	; xxxx xxx0   Color-Luminance Player 0
     65  fc00		       00 07	   COLUP1     =	$07	; xxxx xxx0   Color-Luminance Player 1
     66  fc00		       00 08	   COLUPF     =	$08	; xxxx xxx0   Color-Luminance Playfield
     67  fc00		       00 09	   COLUBK     =	$09	; xxxx xxx0   Color-Luminance Background
     68  fc00		       00 0a	   CTRLPF     =	$0a	; 00xx 0xxx   Control Playfield, Ball, Collisions
     69  fc00		       00 0b	   REFP0      =	$0b	; 0000 x000   Reflection Player 0
     70  fc00		       00 0c	   REFP1      =	$0c	; 0000 x000   Reflection Player 1
     71  fc00		       00 0d	   PF0	      =	$0d	; xxxx 0000   Playfield Register Byte 0
     72  fc00		       00 0e	   PF1	      =	$0e	; xxxx xxxx   Playfield Register Byte 1
     73  fc00		       00 0f	   PF2	      =	$0f	; xxxx xxxx   Playfield Register Byte 2
     74  fc00		       00 10	   RESP0      =	$10	; ---- ----   Reset Player 0
     75  fc00		       00 11	   RESP1      =	$11	; ---- ----   Reset Player 1
     76  fc00		       00 12	   RESM0      =	$12	; ---- ----   Reset Missle 0
     77  fc00		       00 13	   RESM1      =	$13	; ---- ----   Reset Missle 1
     78  fc00		       00 14	   RESBL      =	$14	; ---- ----   Reset Ball
     79  fc00		       00 15	   AUDC0      =	$15	; 0000 xxxx   Audio Control 0
     80  fc00		       00 16	   AUDC1      =	$16	; 0000 xxxx   Audio Control 1
     81  fc00		       00 17	   AUDF0      =	$17	; 000x xxxx   Audio Frequency 0
     82  fc00		       00 18	   AUDF1      =	$18	; 000x xxxx   Audio Frequency 1
     83  fc00		       00 19	   AUDV0      =	$19	; 0000 xxxx   Audio Volume 0
     84  fc00		       00 1a	   AUDV1      =	$1a	; 0000 xxxx   Audio Volume 1
     85  fc00		       00 1b	   GRP0       =	$1b	; xxxx xxxx   Graphics Register Player 0
     86  fc00		       00 1c	   GRP1       =	$1c	; xxxx xxxx   Graphics Register Player 1
     87  fc00		       00 1d	   ENAM0      =	$1d	; 0000 00x0   Graphics Enable Missile 0
     88  fc00		       00 1e	   ENAM1      =	$1e	; 0000 00x0   Graphics Enable Missile 1
     89  fc00		       00 1f	   ENABL      =	$1f	; 0000 00x0   Graphics Enable Ball
     90  fc00		       00 20	   HMP0       =	$20	; xxxx 0000   Horizontal Motion Player 0
     91  fc00		       00 21	   HMP1       =	$21	; xxxx 0000   Horizontal Motion Player 1
     92  fc00		       00 22	   HMM0       =	$22	; xxxx 0000   Horizontal Motion Missile 0
     93  fc00		       00 23	   HMM1       =	$23	; xxxx 0000   Horizontal Motion Missile 1
     94  fc00		       00 24	   HMBL       =	$24	; xxxx 0000   Horizontal Motion Ball
     95  fc00		       00 25	   VDELP0     =	$25	; 0000 000x   Vertical Delay Player 0
     96  fc00		       00 26	   VDELP1     =	$26	; 0000 000x   Vertical Delay Player 1
     97  fc00		       00 27	   VDELBL     =	$27	; 0000 000x   Vertical Delay Ball
     98  fc00		       00 28	   RESMP0     =	$28	; 0000 00x0   Reset Missile 0 to Player 0
     99  fc00		       00 29	   RESMP1     =	$29	; 0000 00x0   Reset Missile 1 to Player 1
    100  fc00		       00 2a	   HMOVE      =	$2a	; ---- ----   Apply Horizontal Motion
    101  fc00		       00 2b	   HMCLR      =	$2b	; ---- ----   Clear Horizontal Move Registers
    102  fc00		       00 2c	   CXCLR      =	$2c	; ---- ----   Clear Collision Latches
    103  fc00
    104  fc00		       00 00	   CXM0P      =	$00	; xx00 0000	   Read Collision  M0-P1   M0-P0
    105  fc00		       00 01	   CXM1P      =	$01	; xx00 0000			   M1-P0   M1-P1
    106  fc00		       00 02	   CXP0FB     =	$02	; xx00 0000			   P0-PF   P0-BL
    107  fc00		       00 03	   CXP1FB     =	$03	; xx00 0000			   P1-PF   P1-BL
    108  fc00		       00 04	   CXM0FB     =	$04	; xx00 0000			   M0-PF   M0-BL
    109  fc00		       00 05	   CXM1FB     =	$05	; xx00 0000			   M1-PF   M1-BL
    110  fc00		       00 06	   CXBLPF     =	$06	; x000 0000			   BL-PF   -----
    111  fc00		       00 07	   CXPPMM     =	$07	; xx00 0000			   P0-P1   M0-M1
    112  fc00		       00 08	   INPT0      =	$08	; x000 0000	   Read Pot Port 0
    113  fc00		       00 09	   INPT1      =	$09	; x000 0000	   Read Pot Port 1
    114  fc00		       00 0a	   INPT2      =	$0a	; x000 0000	   Read Pot Port 2
    115  fc00		       00 0b	   INPT3      =	$0b	; x000 0000	   Read Pot Port 3
    116  fc00		       00 0c	   INPT4      =	$0c	; x000 0000	   Read Input (Trigger) 0
    117  fc00		       00 0d	   INPT5      =	$0d	; x000 0000	   Read Input (Trigger) 1
    118  fc00
    119  fc00							; RIOT MEMORY MAP
    120  fc00
    121  fc00		       02 80	   SWCHA      =	$280	; Port A data register for joysticks:
    122  fc00							; Bits 4-7 for player 1.  Bits 0-3 for player 2.
    123  fc00		       02 81	   SWACNT     =	$281	; Port A data direction register (DDR)
    124  fc00		       02 82	   SWCHB      =	$282	; Port B data (console switches)
    125  fc00		       02 83	   SWBCNT     =	$283	; Port B DDR
    126  fc00		       02 84	   INTIM      =	$284	; Timer output
    127  fc00
    128  fc00		       02 85	   TIMINT     =	$285
    129  fc00
    130  fc00		       02 94	   TIM1T      =	$294	; set 1 clock interval
    131  fc00		       02 95	   TIM8T      =	$295	; set 8 clock interval
    132  fc00		       02 96	   TIM64T     =	$296	; set 64 clock interval
    133  fc00		       02 97	   T1024T     =	$297	; set 1024 clock interval
    134  fc00
    135  fc00							;
    136  fc00							; These are colors for NTSC video, change for PAL
    137  fc00							;
    138  fc00		       00 0e	   color_white =	$0e	; Color for white pieces
    139  fc00		       00 28	   color_black =	$28	; Color for black pieces
    140  fc00		       00 74	   color_white_square =	$74	; Color for white squares
    141  fc00		       00 70	   color_black_square =	$70	; Color for black squares
    142  fc00
    143  fc00				  -	      else
    144  fc00				  -	      org	$0100
    145  fc00					      endif
    146  fc00
    147  fc00		       00 80	   score      =	$80	; Current score
    148  fc00		       00 81	   side       =	$81	; Current side
    149  fc00		       00 82	   offset     =	$82	; Current offset
    150  fc00		       00 83	   total      =	$83	; Current total
    151  fc00		       00 84	   origin     =	$84	; Current origin square
    152  fc00		       00 85	   target     =	$85	; Current target square
    153  fc00
    154  fc00		       00 86	   frame      =	$86	; Current frame
    155  fc00
    156  fc00		       00 87	   cursorx    =	$87	; Current X position of cursor
    157  fc00		       00 88	   cursory    =	$88	; Current Y position of cursor
    158  fc00
    159  fc00		       00 89	   pSWCHA     =	$89	; Previous value of SWCHA
    160  fc00		       00 8a	   pINPT4     =	$8A	; Previous value of INPT4
    161  fc00
    162  fc00							; Reused locations
    163  fc00		       00 82	   bitmap0    =	$82	; Index into bitmap (0)
    164  fc00		       00 83	   bitmap1    =	$83	; Index into bitmap (1)
    165  fc00		       00 81	   bitmap2    =	$81	; Index into bitmap (2)
    166  fc00		       00 8b	   bitmap3    =	$8b	; Index into bitmap (3)
    167  fc00		       00 80	   even       =	$80	; Marks even/odd
    168  fc00
    169  fc00		       00 8c	   board      =	$8c	; 78 bytes used, there should be space for 12+12+10 bytes of stack
    170  fc00
    171  fc00				   START
    172  fc00		       78		      sei		; Disable interruptions
    173  fc01		       d8		      cld		; Disable decimal mode
    174  fc02					      if	mode = atari
    175  fc02							; Clean up the memory
    176  fc02		       a9 00		      lda	#0	; Load zero in accumulator
    177  fc04		       aa		      tax		; ...copy in X
    178  fc05		       95 00	   sr0	      sta	0,X	; Save in address 0 plus X
    179  fc07		       9a		      txs		; Copy X in S (stack) last value will be $ff
    180  fc08		       e8		      inx		; Increment X
    181  fc09		       d0 fa		      bne	sr0	; Repeat until X is zero.
    182  fc0b
    183  fc0b		       8d 81 02 	      sta	SWACNT	; Allow to read joysticks
    184  fc0e		       8d 83 02 	      sta	SWBCNT	; Allow to read buttons
    185  fc11							;	 ldx #0       ; x is zero
    186  fc11				  -	      else
    187  fc11				  -			; Clean up the memory
    188  fc11				  -	      ldx	#$ff
    189  fc11				  -	      txs
    190  fc11				  -	      lda	#$00	; Load zero in accumulator
    191  fc11				  -	      ldx	#$80	; ...copy in X
    192  fc11				  -sr0	      sta	0,X	; Save in address 0 plus X
    193  fc11				  -	      inx		; Increment X
    194  fc11				  -	      cpx	#$8c
    195  fc11				  -	      bne	sr0	; Repeat until X is zero.
    196  fc11				  -	      tax		; x is zero
    197  fc11					      endif
    198  fc11
    199  fc11		       a0 08	   sr1	      ldy	#8
    200  fc13		       a9 00	   sr3	      lda	#$00
    201  fc15		       95 8c		      sta	board,x
    202  fc17		       e8		      inx
    203  fc18		       88		      dey
    204  fc19		       d0 f8		      bne	sr3
    205  fc1b		       a9 07		      lda	#$07
    206  fc1d		       95 8c		      sta	board,x
    207  fc1f		       e8		      inx
    208  fc20		       95 8c		      sta	board,x
    209  fc22		       e8		      inx
    210  fc23		       e0 50		      cpx	#8*10
    211  fc25		       d0 ea		      bne	sr1
    212  fc27		       aa		      tax		; a was $07, so x = $07
    213  fc28		       bd b5 ff    sr2	      lda	initial,x
    214  fc2b		       95 8c		      sta	board,x
    215  fc2d		       09 08		      ora	#$08
    216  fc2f		       95 d2		      sta	board+70,x
    217  fc31		       f6 96		      inc	board+10,x
    218  fc33		       a9 09		      lda	#$09
    219  fc35		       95 c8		      sta	board+60,x
    220  fc37		       ca		      dex
    221  fc38		       10 ee		      bpl	sr2
    222  fc3a		       4a		      lsr		; lda #4, but A was $09 / 2 = $04
    223  fc3b		       85 87		      sta	cursorx
    224  fc3d		       85 88		      sta	cursory
    225  fc3f
    226  fc3f							;
    227  fc3f							; Main loop
    228  fc3f							;
    229  fc3f				   sr21
    230  fc3f					      if	mode = atari
    231  fc3f				  -	      else
    232  fc3f				  -	      jsr	kernel
    233  fc3f					      endif
    234  fc3f		       20 47 ff 	      jsr	read_coor
    235  fc42		       b9 8c 00 	      lda	board,y
    236  fc45		       29 08		      and	#8	; Check for white piece
    237  fc47		       f0 f6		      beq	sr21	; If no, jump and restart selection logic
    238  fc49		       20 47 ff    sr11       jsr	read_coor
    239  fc4c		       b9 8c 00 	      lda	board,y
    240  fc4f		       29 08		      and	#8	; Check for white piece
    241  fc51		       d0 f6		      bne	sr11	; If yes, restart target square logic
    242  fc53		       20 86 fc 	      jsr	sr28	; Make movement
    243  fc56					      if	mode = atari
    244  fc56		       a2 3f		      ldx	#63
    245  fc58		       8a	   kn0	      txa
    246  fc59		       48		      pha
    247  fc5a		       4a		      lsr
    248  fc5b		       4a		      lsr
    249  fc5c		       85 19		      sta	AUDV0
    250  fc5e		       20 a3 fd 	      jsr	kernel
    251  fc61		       68		      pla
    252  fc62		       aa		      tax
    253  fc63		       ca		      dex
    254  fc64		       d0 f2		      bne	kn0
    255  fc66				  -	      else
    256  fc66				  -	      jsr	kernel
    257  fc66					      endif
    258  fc66		       20 a2 fc 	      jsr	play	; Computer play
    259  fc69		       4c 3f fc 	      jmp	sr21
    260  fc6c
    261  fc6c							;
    262  fc6c							; Start chess playing code, this code is the end of loop but it's here
    263  fc6c							; to save bytes ;)
    264  fc6c							;
    265  fc6c		       e6 82	   sr14       inc	offset
    266  fc6e		       c6 83		      dec	total
    267  fc70		       d0 58		      bne	sr12
    268  fc72		       e8	   sr17       inx
    269  fc73		       e0 4e		      cpx	#78
    270  fc75		       d0 33		      bne	sr7
    271  fc77		       68		      pla
    272  fc78		       a8		      tay
    273  fc79		       68		      pla
    274  fc7a		       ba		      tsx
    275  fc7b		       e0 fd		      cpx	#$ff-2	; Top call? (2 bytes of return address)
    276  fc7d		       d0 22		      bne	sr24
    277  fc7f		       a6 80		      ldx	score
    278  fc81		       e0 d3		      cpx	#$c0+19	; Illegal move? (always in check)
    279  fc83		       30 1c		      bmi	sr24	; Yes, doesn't move
    280  fc85		       aa		      tax
    281  fc86		       b5 8c	   sr28       lda	board,x	; Do move
    282  fc88		       c9 01		      cmp	#1
    283  fc8a		       f0 04		      beq	sr32
    284  fc8c		       c9 09		      cmp	#9	; Is it pawn?
    285  fc8e		       d0 0a		      bne	sr30
    286  fc90		       c0 0a	   sr32       cpy	#10	; Reaching border?
    287  fc92		       90 04		      bcc	sr31
    288  fc94		       c0 46		      cpy	#70
    289  fc96		       90 02		      bcc	sr30
    290  fc98		       49 05	   sr31       eor	#5	; Make it queen
    291  fc9a		       99 8c 00    sr30       sta	board,y
    292  fc9d		       a9 00		      lda	#0	; Clear origin square
    293  fc9f		       95 8c		      sta	board,x
    294  fca1		       60	   sr24       rts
    295  fca2
    296  fca2							;
    297  fca2							; Computer plays :)
    298  fca2							;
    299  fca2		       a9 c0	   play       lda	#$c0	; Current score (-64)
    300  fca4		       85 80		      sta	score
    301  fca6		       48		      pha		; Origin square of best movement (currently none)
    302  fca7		       48		      pha		; Target square of best movement
    303  fca8		       a2 00		      ldx	#0	; x points to current square
    304  fcaa		       b5 8c	   sr7	      lda	board,x	; Read square
    305  fcac		       f0 c4		      beq	sr17	; Ignore if empty square
    306  fcae		       45 81		      eor	side	; XOR with current playing side
    307  fcb0		       c9 07		      cmp	#7	; Ignore if frontier
    308  fcb2		       b0 be		      bcs	sr17
    309  fcb4		       c9 01		      cmp	#1	; Is it pawn?
    310  fcb6		       d0 06		      bne	sr25	; Carry will be 1 always because 1<=A<=6
    311  fcb8		       a4 81		      ldy	side	; Is it playing black?
    312  fcba		       f0 02		      beq	sr25	; Yes, jump
    313  fcbc		       a9 00		      lda	#0	; Make it zero for white
    314  fcbe		       a8	   sr25       tay
    315  fcbf		       69 03		      adc	#3	; Adds 4 because carry is 1 (see above)
    316  fcc1		       29 0c		      and	#$0c
    317  fcc3		       85 83		      sta	total	; Total movements of piece
    318  fcc5		       b9 c3 ff 	      lda	offsets,y
    319  fcc8		       85 82		      sta	offset	; Next offset for movement
    320  fcca		       86 85	   sr12       stx	target	; Restart target square
    321  fccc		       a4 82	   sr9	      ldy	offset
    322  fcce		       b9 ca ff 	      lda	displacement,y
    323  fcd1		       18		      clc
    324  fcd2		       65 85		      adc	target	; Next target square
    325  fcd4		       c9 4e		      cmp	#78	; Out of board?
    326  fcd6		       b0 94		      bcs	sr14
    327  fcd8		       85 85		      sta	target
    328  fcda
    329  fcda		       c0 10		      cpy	#16
    330  fcdc		       a8		      tay
    331  fcdd		       b9 8c 00 	      lda	board,y	; Content of target square
    332  fce0		       f0 26		      beq	sr10	; Jump if empty square
    333  fce2		       90 06		      bcc	sr27	; Jump if isn't not pawn
    334  fce4		       a5 83		      lda	total
    335  fce6		       c9 03		      cmp	#3	; Straight?
    336  fce8		       90 88		      bcc	sr17	; Yes, avoid and cancels any double square movement
    337  fcea		       b9 8c 00    sr27       lda	board,y
    338  fced		       45 81		      eor	side
    339  fcef		       38		      sec
    340  fcf0		       e9 09		      sbc	#9	; Valid capture?
    341  fcf2		       c9 06		      cmp	#6
    342  fcf4		       b0 1a		      bcs	sr29	; No, avoid (too far for sr18, use sr29 as bridge)
    343  fcf6		       c9 05		      cmp	#5
    344  fcf8		       d0 23		      bne	sr20	; Jump if not captured king
    345  fcfa		       68		      pla		; Ignore values
    346  fcfb		       68		      pla
    347  fcfc		       ba		      tsx
    348  fcfd		       a9 2d		      lda	#$3f-18	; Maximum score minus two queens...
    349  fcff		       e0 f1		      cpx	#$f1	; ...if not in first response.
    350  fd01		       d0 02		      bne	sr26
    351  fd03		       a9 3f		      lda	#$3f	; Maximum score (probably checkmate/stalemate)
    352  fd05		       85 80	   sr26       sta	score
    353  fd07		       60		      rts
    354  fd08
    355  fd08		       90 13	   sr10       bcc	sr20	; If isn't pawn, jump.
    356  fd0a		       a5 83		      lda	total
    357  fd0c		       c9 02		      cmp	#2	; Diagonal?
    358  fd0e		       f0 04		      beq	sr15	; Jump if one square ahead
    359  fd10		       b0 7a	   sr29       bcs	sr18	; Yes, avoid
    360  fd12		       90 09		      bcc	sr20
    361  fd14
    362  fd14		       8a	   sr15       txa
    363  fd15							;sec		 ; Carry set already because equality comparison
    364  fd15		       e9 14		      sbc	#20
    365  fd17		       c9 28		      cmp	#40	; Moving from center of board?
    366  fd19		       b0 02		      bcs	sr20
    367  fd1b		       c6 83		      dec	total	; Yes, then avoid checking for two squares
    368  fd1d							;bcc sr20	 ; Fall along
    369  fd1d
    370  fd1d							; Save all state
    371  fd1d		       a5 82	   sr20       lda	offset	; Offset for movement
    372  fd1f		       48		      pha
    373  fd20		       a5 83		      lda	total	; Total directions left
    374  fd22		       48		      pha
    375  fd23		       b9 8c 00 	      lda	board,y	; Content of target square
    376  fd26		       48		      pha
    377  fd27		       98		      tya		; Target square
    378  fd28		       48		      pha
    379  fd29		       b5 8c		      lda	board,x	; Content of origin square
    380  fd2b		       48		      pha
    381  fd2c		       8a		      txa		; Origin square
    382  fd2d		       85 84		      sta	origin
    383  fd2f		       48		      pha
    384  fd30		       b9 8c 00 	      lda	board,y
    385  fd33		       29 07		      and	#7
    386  fd35		       a8		      tay
    387  fd36		       b9 bd ff 	      lda	scores,y	; Score for capture
    388  fd39		       ba		      tsx
    389  fd3a					      if	mode = atari
    390  fd3a		       e0 e2		      cpx	#255-10*3+1	; Depth limit (2-ply)
    391  fd3c				  -	      else
    392  fd3c				  -	      cpx	#255-10*2+1	; Depth limit (1-ply)
    393  fd3c					      endif
    394  fd3c		       90 22		      bcc	sr22
    395  fd3e		       48		      pha
    396  fd3f		       a5 80		      lda	score	; Current score
    397  fd41		       48		      pha
    398  fd42		       a6 84		      ldx	origin
    399  fd44		       a4 85		      ldy	target
    400  fd46		       20 86 fc 	      jsr	sr28	; Do move
    401  fd49		       a5 81		      lda	side
    402  fd4b		       49 08		      eor	#8	; Change side (doesn't save in stack because lack of space)
    403  fd4d		       85 81		      sta	side
    404  fd4f		       20 a2 fc 	      jsr	play
    405  fd52		       a5 81		      lda	side
    406  fd54		       49 08		      eor	#8	; Change side
    407  fd56		       85 81		      sta	side
    408  fd58		       68		      pla
    409  fd59		       aa		      tax		; Current score in x
    410  fd5a		       68		      pla
    411  fd5b		       38		      sec		; Take capture score and substract adversary score
    412  fd5c		       e5 80		      sbc	score
    413  fd5e		       86 80		      stx	score	; Restore current score
    414  fd60		       c5 80	   sr22       cmp	score	; Better score?
    415  fd62		       18		      clc
    416  fd63		       30 0c		      bmi	sr23	; No, jump
    417  fd65		       d0 07		      bne	sr33	; Better score? yes, jump
    418  fd67		       a5 86		      lda	frame	; Equal score, randomize move
    419  fd69		       6a		      ror
    420  fd6a		       6a		      ror
    421  fd6b		       4c 71 fd 	      jmp	sr23	; No need to update score but carry = 1 will update move
    422  fd6e							;bcc sr23
    423  fd6e							;bcs sr23
    424  fd6e		       85 80	   sr33       sta	score	; Update score
    425  fd70		       38		      sec
    426  fd71		       68	   sr23       pla		; Restore board
    427  fd72		       aa		      tax
    428  fd73		       68		      pla
    429  fd74		       95 8c		      sta	board,x
    430  fd76		       68		      pla
    431  fd77		       85 85		      sta	target
    432  fd79		       a8		      tay
    433  fd7a		       68		      pla
    434  fd7b		       99 8c 00 	      sta	board,y
    435  fd7e		       68		      pla
    436  fd7f		       85 83		      sta	total
    437  fd81		       68		      pla
    438  fd82		       85 82		      sta	offset
    439  fd84		       90 06		      bcc	sr18
    440  fd86		       68		      pla
    441  fd87		       68		      pla
    442  fd88		       8a		      txa		; Save current best movement
    443  fd89		       48		      pha
    444  fd8a		       98		      tya
    445  fd8b		       48		      pha
    446  fd8c
    447  fd8c		       b5 8c	   sr18       lda	board,x
    448  fd8e		       29 07		      and	#7
    449  fd90		       c9 01		      cmp	#1	; Was it pawn?
    450  fd92		       f0 0c		      beq	sr16	; Yes, end sequence, choose next movement
    451  fd94		       c9 05		      cmp	#5	; Knight or king?
    452  fd96		       b0 08		      bcs	sr16	; End sequence, choose next movement
    453  fd98		       b9 8c 00 	      lda	board,y	; To empty square?
    454  fd9b		       d0 03		      bne	sr16
    455  fd9d		       4c cc fc 	      jmp	sr9	; Yes, follow line of squares
    456  fda0
    457  fda0		       4c 6c fc    sr16       jmp	sr14
    458  fda3
    459  fda3					      if	mode = atari
    460  fda3							;
    461  fda3							; Set object in X
    462  fda3							; A = X position
    463  fda3							; First arg = Object to position (0=P0, 1=P1, 2=M0, 3=M1, 4=BALL)
    464  fda3							; Exits with carry = 0, it can set V flag for X >= 128
    465  fda3							;
    466  fda3					      MAC	set_x_position
    467  fda3					      sta	WSYNC	; 0- Start line synchro
    468  fda3					      sec		; 3- Set carry flag (avoids it in loop)
    469  fda3				   .AE2       sbc	#15	; 5- Uses required time dividing A by 15
    470  fda3					      bcs	.AE2	; 7/8 - 9/14/19/24/29/34/39/44/49/54/59/64
    471  fda3					      tay		; 9
    472  fda3					      lda	fine_adjustment-$f1,y	; 11 - Eats 5 cycles crossing page
    473  fda3					      sta	HMP0+{1}	; 16
    474  fda3					      nop		; 19
    475  fda3					      sta	RESP0+{1}	; 21/26/31/36/41/46/51/56/61/66/71 - "big" positioning
    476  fda3					      ENDM
    477  fda3
    478  fda3							;
    479  fda3							; Display kernel
    480  fda3							;
    481  fda3				   kernel
    482  fda3		       a9 00		      lda	#$00
    483  fda5		       85 09		      sta	COLUBK	; Background color (border in this case)
    484  fda7
    485  fda7							; VERTICAL_SYNC
    486  fda7		       a2 02		      ldx	#2
    487  fda9		       86 00		      stx	VSYNC	; Start vertical synchro
    488  fdab		       86 02		      stx	WSYNC	; Wait for 3 lines
    489  fdad		       86 02		      stx	WSYNC
    490  fdaf		       86 02		      stx	WSYNC
    491  fdb1							;
    492  fdb1		       a2 2b		      ldx	#43
    493  fdb3		       8e 96 02 	      stx	TIM64T
    494  fdb6		       85 00		      sta	VSYNC	; Stop vertical synchro
    495  fdb8		       85 1b		      sta	GRP0	; Clear player 0 bitmap
    496  fdba		       85 1c		      sta	GRP1	; Clear player 1 bitmap
    497  fdbc		       a9 70		      lda	#color_black_square
    498  fdbe		       85 09		      sta	COLUBK	; Background color
    499  fdc0		       a9 35		      lda	#$35	; Double-size player, 8-pixel missile
    500  fdc2		       85 04		      sta	NUSIZ0	; Size of player/missile 0
    501  fdc4		       85 05		      sta	NUSIZ1	; Size of player/missile 1
    502  fdc6		       a9 74		      lda	#color_white_square
    503  fdc8		       85 08		      sta	COLUPF	; Color of playfield
    504  fdca		       a5 87		      lda	cursorx	; Get X-position of cursor and set up missile 0
    505  fdcc		       0a		      asl		; x2
    506  fdcd		       0a		      asl		; x4
    507  fdce		       85 80		      sta	even
    508  fdd0		       0a		      asl		; x8
    509  fdd1		       0a		      asl		; x16
    510  fdd2		       65 80		      adc	even	; x20 Can set V flag for eighth square (cursorx = 7)
    511  fdd4		       69 0e		      adc	#14
    512  fdd6		       c9 0e		      cmp	#14
    513  fdd8		       d0 02		      bne	*+4
    514  fdda		       e9 03		      sbc	#3
      0  fddc					      set_x_position	2
      1  fddc		       85 02		      sta	WSYNC
      2  fdde		       38		      sec
      3  fddf		       e9 0f	   .AE2       sbc	#15
      4  fde1		       b0 fc		      bcs	.AE2
      5  fde3		       a8		      tay
      6  fde4		       b9 47 fe 	      lda	fine_adjustment-$f1,y
      7  fde7		       85 22		      sta	HMP0+2
      8  fde9		       ea		      nop
      9  fdea		       85 12		      sta	RESP0+2
    516  fdec		       85 02		      sta	WSYNC
    517  fdee		       85 2a		      sta	HMOVE	; Fine adjustment for all set_x_position
    518  fdf0
    519  fdf0				   wait_vblank
    520  fdf0		       ad 84 02 	      lda	INTIM
    521  fdf3		       d0 fb		      bne	wait_vblank
    522  fdf5							;
    523  fdf5							; Start of graphics
    524  fdf5							;
    525  fdf5							; Each graphic line sizes up to 76 cycles of 6502 processor.
    526  fdf5							;
    527  fdf5							; Doing STA WSYNC isn't required but it helps to clarify where
    528  fdf5							; each video line starts.
    529  fdf5							;
    530  fdf5		       85 02		      sta	WSYNC
    531  fdf7		       85 01		      sta	VBLANK
    532  fdf9		       85 80		      sta	even	; Now uses like row counter, start at zero
    533  fdfb		       a5 86		      lda	frame	; Board position per frame
    534  fdfd		       29 01		      and	#1
    535  fdff		       0a		      asl
    536  fe00		       aa	   ds0	      tax
    537  fe01		       85 02	   ds1	      sta	WSYNC	; 0 Row 0
    538  fe03		       a5 80		      lda	even	; 3 Squares configuration over board
    539  fe05		       4a		      lsr		; 6
    540  fe06		       90 0a		      bcc	ds6	; 8
    541  fe08		       a9 00		      lda	#$00	; 10
    542  fe0a		       85 0d		      sta	PF0	; 12
    543  fe0c		       a0 7c		      ldy	#$7c	; 15
    544  fe0e		       a9 f8		      lda	#$f8	; 17
    545  fe10		       d0 08		      bne	ds7	; 19
    546  fe12
    547  fe12		       a9 f0	   ds6	      lda	#$f0	; 11
    548  fe14		       85 0d		      sta	PF0	; 13
    549  fe16		       a0 83		      ldy	#$83	; 16
    550  fe18		       a9 07		      lda	#$07	; 18
    551  fe1a		       84 0e	   ds7	      sty	PF1	; 20/22
    552  fe1c		       85 0f		      sta	PF2	; 23/25
    553  fe1e		       b5 8c		      lda	board,x	; 26/28 Bitmap for piece at column offset 0
    554  fe20		       29 07		      and	#7	; 30/34
    555  fe22		       0a		      asl		; 32
    556  fe23		       0a		      asl		; 34
    557  fe24		       0a		      asl		; 36
    558  fe25		       85 82		      sta	bitmap0	; 38
    559  fe27		       b5 8d		      lda	board+1,x	; 41 Bitmap for piece at column offset 1
    560  fe29		       29 07		      and	#7	; 45
    561  fe2b		       0a		      asl		; 47
    562  fe2c		       0a		      asl		; 49
    563  fe2d		       0a		      asl		; 51 
    564  fe2e		       85 83		      sta	bitmap1	; 53
    565  fe30		       85 02		      sta	WSYNC	; 0 Row 1
    566  fe32		       a5 80		      lda	even	; 3 Check if row...
    567  fe34		       c5 88		      cmp	cursory	; 6 ...equals row of cursor
    568  fe36		       08		      php		; 9 Save Z flag...
    569  fe37		       68		      pla		; 12 ...so it goes to bit 1
    570  fe38		       85 1d		      sta	ENAM0	; 16 Enable missile if at right Y position
    571  fe3a		       b5 90		      lda	board+4,x	; 19 Bitmap for piece at column offset 4
    572  fe3c		       29 07		      and	#7	; 23
    573  fe3e		       0a		      asl		; 25
    574  fe3f		       0a		      asl		; 27
    575  fe40		       0a		      asl		; 29
    576  fe41		       85 81		      sta	bitmap2	; 31
    577  fe43		       b5 91		      lda	board+5,x	; 34 Bitmap for piece at column offset 5
    578  fe45		       29 07		      and	#7	; 38
    579  fe47		       0a		      asl		; 40
    580  fe48		       0a		      asl		; 42
    581  fe49		       0a		      asl		; 44
    582  fe4a		       85 8b		      sta	bitmap3	; 46
    583  fe4c							;
    584  fe4c							; Do loop to draw 21 scanlines
    585  fe4c							;
    586  fe4c		       85 02	   ds3	      sta	WSYNC	; 0
    587  fe4e		       a9 00		      lda	#0	; 3
    588  fe50		       85 1b		      sta	GRP0	; 5
    589  fe52		       85 1c		      sta	GRP1	; 8
    590  fe54		       a5 86		      lda	frame	; 11
    591  fe56		       4a		      lsr		; 14
    592  fe57		       90 3d		      bcc	ds9	; 16
    593  fe59		       48		      pha		; 18
    594  fe5a		       68		      pla		; 21
    595  fe5b		       48		      pha		; 25
    596  fe5c		       68		      pla		; 28
    597  fe5d		       a5 82		      lda	bitmap0	; 32
    598  fe5f		       85 10		      sta	RESP0	; 35
    599  fe61		       a5 82	   ds11       lda	bitmap0	; 38/25
    600  fe63		       85 11		      sta	RESP1	; 41/28
    601  fe65
    602  fe65		       b4 8c		      ldy	board,x	; 44 Check color for first piece
    603  fe67		       b9 e2 ff 	      lda	pieces_color,y	; 48
    604  fe6a		       85 06		      sta	COLUP0	; 52
    605  fe6c		       b4 8d		      ldy	board+1,x	; 55 Check color for second piece
    606  fe6e		       b9 e2 ff 	      lda	pieces_color,y	; 59
    607  fe71		       85 07		      sta	COLUP1	; 63
    608  fe73		       a4 82		      ldy	bitmap0	; 66
    609  fe75		       b9 00 ff 	      lda	pieces,y	; 69
    610  fe78
    611  fe78		       85 02		      sta	WSYNC	; Start scanline to draw 2 pieces at left
    612  fe7a		       0a		      asl		; 3
    613  fe7b		       85 1b		      sta	GRP0	; 5
    614  fe7d		       a4 83		      ldy	bitmap1	; 8
    615  fe7f		       b9 00 ff 	      lda	pieces,y	; 11
    616  fe82		       85 1c		      sta	GRP1	; 15
    617  fe84		       a5 86		      lda	frame
    618  fe86		       4a		      lsr
    619  fe87		       ea		      nop		; 30
    620  fe88		       ea		      nop
    621  fe89		       b4 90		      ldy	board+4,x	; 35 Check color for third piece (next scanline)
    622  fe8b		       b9 e2 ff 	      lda	pieces_color,y	; 39
    623  fe8e		       90 0a		      bcc	ds5	; 28
    624  fe90		       48		      pha
    625  fe91		       68		      pla
    626  fe92		       ea		      nop
    627  fe93		       ea		      nop
    628  fe94		       d0 04		      bne	ds5
    629  fe96
    630  fe96		       85 10	   ds9	      sta	RESP0	; 19
    631  fe98		       90 c7		      bcc	ds11	; 22
    632  fe9a
    633  fe9a		       85 06	   ds5	      sta	COLUP0
    634  fe9c		       b4 91		      ldy	board+5,x	; 57 Check color for the two pieces
    635  fe9e		       b9 e2 ff 	      lda	pieces_color,y	; 61
    636  fea1		       85 10		      sta	RESP0	; 48
    637  fea3		       85 07		      sta	COLUP1	; 43
    638  fea5		       85 11		      sta	RESP1	; 54
    639  fea7		       a4 81		      ldy	bitmap2	; 3 
    640  fea9
    641  fea9		       85 02		      sta	WSYNC	; 0
    642  feab		       b9 00 ff 	      lda	pieces,y	; 3
    643  feae		       0a		      asl		; 7
    644  feaf		       85 1b		      sta	GRP0	; 9
    645  feb1		       a4 8b		      ldy	bitmap3	; 12
    646  feb3		       b9 00 ff 	      lda	pieces,y	; 15
    647  feb6		       85 1c		      sta	GRP1	; 19
    648  feb8		       e6 82		      inc	bitmap0	; 22
    649  feba		       e6 83		      inc	bitmap1	; 27
    650  febc		       e6 81		      inc	bitmap2	; 32
    651  febe		       e6 8b		      inc	bitmap3	; 37
    652  fec0		       98		      tya		; 42
    653  fec1		       29 07		      and	#7	; 44
    654  fec3		       38		      sec		; 46
    655  fec4		       e9 06		      sbc	#6	; 48
    656  fec6		       f0 03		      beq	ds12	; 50
    657  fec8		       4c 4c fe 	      jmp	ds3	; 52 + 3
    658  fecb				   ds12
    659  fecb		       85 1d		      sta	ENAM0	; Disable cursor
    660  fecd		       e6 80		      inc	even	; Increase current row
    661  fecf		       8a		      txa
    662  fed0		       18		      clc		;
    663  fed1		       69 0a		      adc	#10	; Next row of board
    664  fed3		       c9 50		      cmp	#80	; Completed chessboard?
    665  fed5		       b0 03		      bcs	ds8	; Yes, jump
    666  fed7		       4c 00 fe 	      jmp	ds0	; No, continue
    667  feda				   ds8
    668  feda
    669  feda							;
    670  feda							; End of graphics (204 lines)
    671  feda							;
    672  feda		       a9 02		      lda	#2
    673  fedc		       85 02		      sta	WSYNC
    674  fede		       85 01		      sta	VBLANK
    675  fee0
    676  fee0							;
    677  fee0							; Start overscan timer
    678  fee0							;
    679  fee0		       a9 2b		      lda	#43	; 37 lines * 76 = 2812 cycles / 64 = 43.9375
    680  fee2		       8d 96 02 	      sta	TIM64T
    681  fee5				   wait_overscan
    682  fee5		       ad 84 02 	      lda	INTIM
    683  fee8		       d0 fb		      bne	wait_overscan
    684  feea		       85 02		      sta	WSYNC
    685  feec		       85 0d		      sta	PF0
    686  feee		       85 0e		      sta	PF1
    687  fef0		       85 0f		      sta	PF2
    688  fef2		       85 02		      sta	WSYNC
    689  fef4		       85 81		      sta	side	; Black side plays
    690  fef6
    691  fef6		       e6 86		      inc	frame
    692  fef8
    693  fef8		       60		      rts
    694  fef9
 Free bytes section 1 ($fc00-$feff):  $7
    695  fef9					      echo	"Free bytes section 1 ($fc00-$feff): ",$ff00-*
    696  fef9
    697  ff00					      org	$ff00
    698  ff00				   pieces
    699  ff00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00
    700  ff08		       00 18 3c 3c*	      .byte.b	$00,$18,$3c,$3c,$18,$3c,$00,$00
    701  ff10		       5a 7e 3c 3c*	      .byte.b	$5a,$7e,$3c,$3c,$7e,$7e,$00,$00
    702  ff18		       18 3c 3c 3c*	      .byte.b	$18,$3c,$3c,$3c,$18,$66,$00,$00
    703  ff20		       5a 5a 24 3c*	      .byte.b	$5a,$5a,$24,$3c,$3c,$3c,$00,$00
    704  ff28		       70 58 7c 6e*	      .byte.b	$70,$58,$7c,$6e,$1e,$3e,$00,$00
    705  ff30		       3c 6a 56 3c*	      .byte.b	$3c,$6a,$56,$3c,$3c,$3c,$00,$00
    706  ff38
    707  ff38				   fine_adjustment
    708  ff38		       70		      .byte.b	$70	; -7 
    709  ff39		       60		      .byte.b	$60	; -6 
    710  ff3a		       50		      .byte.b	$50	; -5
    711  ff3b		       40		      .byte.b	$40	; -4
    712  ff3c		       30		      .byte.b	$30	; -3
    713  ff3d		       20		      .byte.b	$20	; -2
    714  ff3e		       10		      .byte.b	$10	; -1
    715  ff3f		       00		      .byte.b	$00	; 0
    716  ff40		       f0		      .byte.b	$f0	; +1
    717  ff41		       e0		      .byte.b	$e0	; +2
    718  ff42		       d0		      .byte.b	$d0	; +3
    719  ff43		       c0		      .byte.b	$c0	; +4
    720  ff44		       b0		      .byte.b	$b0	; +5
    721  ff45		       a0		      .byte.b	$a0	; +6
    722  ff46		       90		      .byte.b	$90	; +7
    723  ff47
    724  ff47							;
    725  ff47							; Read a coordinate choosen by cursor
    726  ff47							; Moves y to x, y contains new coordinate.
    727  ff47							;
    728  ff47				   read_coor
    729  ff47		       98		      tya
    730  ff48		       48		      pha
    731  ff49		       20 8d ff 	      jsr	read_coor2
    732  ff4c		       a8		      tay
    733  ff4d		       68		      pla
    734  ff4e		       aa		      tax
    735  ff4f		       60		      rts
    736  ff50
    737  ff50		       a0 00	   rc5	      ldy	#0
    738  ff52		       ad 80 02 	      lda	SWCHA	; Read current state of joystick
    739  ff55		       49 ff		      eor	#$ff	; 0= Not pressed, 1= pressed
    740  ff57		       85 80		      sta	even
    741  ff59		       aa		      tax
    742  ff5a		       45 89		      eor	pSWCHA	; XOR with previous state
    743  ff5c		       86 89		      stx	pSWCHA	; Save new state
    744  ff5e		       25 80		      and	even	; Disable unchanged directions
    745  ff60		       10 02		      bpl	rc0	; Jump if not going right
    746  ff62		       e6 87		      inc	cursorx
    747  ff64
    748  ff64		       29 f0	   rc0	      and	#$f0
    749  ff66		       f0 02		      beq	rc4
    750  ff68		       a0 08		      ldy	#8	; Sound effect for movement
    751  ff6a		       2a	   rc4	      rol		; Jump if not going left
    752  ff6b		       10 02		      bpl	rc1
    753  ff6d		       c6 87		      dec	cursorx
    754  ff6f
    755  ff6f		       2a	   rc1	      rol		; Jump if not going down
    756  ff70		       10 02		      bpl	rc2
    757  ff72		       e6 88		      inc	cursory
    758  ff74
    759  ff74				   rc2
    760  ff74		       2a		      rol		; Jump if not going up
    761  ff75		       10 02		      bpl	rc3
    762  ff77		       c6 88		      dec	cursory
    763  ff79				   rc3
    764  ff79		       a5 87		      lda	cursorx
    765  ff7b		       29 07		      and	#7
    766  ff7d		       85 87		      sta	cursorx
    767  ff7f		       a5 88		      lda	cursory
    768  ff81		       29 07		      and	#7
    769  ff83		       85 88		      sta	cursory
    770  ff85		       a2 01		      ldx	#$01
    771  ff87		       86 15		      stx	AUDC0
    772  ff89		       84 19		      sty	AUDV0
    773  ff8b		       84 17		      sty	AUDF0
    774  ff8d							;	 jmp read_coor2     ; Fall thru
    775  ff8d							;
    776  ff8d							; Read a coordinate in a
    777  ff8d							;
    778  ff8d				   read_coor2
    779  ff8d		       20 a3 fd 	      jsr	kernel
    780  ff90							;lda #0	    ; Kernel returns with a = 0
    781  ff90		       85 19		      sta	AUDV0
    782  ff92		       a5 0c		      lda	INPT4	; Read current state of button
    783  ff94		       85 80		      sta	even
    784  ff96		       aa		      tax
    785  ff97		       45 8a		      eor	pINPT4
    786  ff99		       86 8a		      stx	pINPT4
    787  ff9b		       49 ff		      eor	#$ff
    788  ff9d		       05 80		      ora	even	; Disable unchanged button
    789  ff9f		       30 af		      bmi	rc5	; Jump if button not pressed
    790  ffa1							;
    791  ffa1							; Computer plays
    792  ffa1							;
    793  ffa1		       a2 03		      ldx	#$03
    794  ffa3		       86 15		      stx	AUDC0
    795  ffa5		       a2 08		      ldx	#$08
    796  ffa7		       86 19		      stx	AUDV0
    797  ffa9		       86 17		      stx	AUDF0
    798  ffab		       a5 88		      lda	cursory	; y_coor 
    799  ffad		       0a		      asl		; *2
    800  ffae		       0a		      asl		; *4
    801  ffaf		       65 88		      adc	cursory	; *5
    802  ffb1		       0a		      asl		; *10
    803  ffb2		       65 87		      adc	cursorx	; + x_coor
    804  ffb4		       60		      rts
    805  ffb5
    806  ffb5				  -	      else
    807  ffb5				  -kernel
    808  ffb5				  -	      jsr	headers
    809  ffb5				  -	      lda	#$38
    810  ffb5				  -	      sta	bitmap0
    811  ffb5				  -	      ldx	#0
    812  ffb5				  -kn0	      lda	bitmap0
    813  ffb5				  -	      sta	$0f
    814  ffb5				  -	      lda	#$20
    815  ffb5				  -	      sta	$0f
    816  ffb5				  -	      ldy	#8
    817  ffb5				  -kn1	      txa
    818  ffb5				  -	      pha
    819  ffb5				  -	      lda	board,x
    820  ffb5				  -	      tax
    821  ffb5				  -	      lda	letters,x
    822  ffb5				  -	      sta	$0f
    823  ffb5				  -	      lda	#$20
    824  ffb5				  -	      sta	$0f
    825  ffb5				  -	      pla
    826  ffb5				  -	      tax
    827  ffb5				  -	      inx
    828  ffb5				  -	      dey
    829  ffb5				  -	      bne	kn1
    830  ffb5				  -	      lda	bitmap0
    831  ffb5				  -	      sta	$0f
    832  ffb5				  -	      lda	#$0a
    833  ffb5				  -	      sta	$0f
    834  ffb5				  -	      dec	bitmap0
    835  ffb5				  -	      inx
    836  ffb5				  -	      inx
    837  ffb5				  -	      cpx	#80
    838  ffb5				  -	      bne	kn0
    839  ffb5				  -	      jsr	headers
    840  ffb5				  -	      rts
    841  ffb5				  -
    842  ffb5				  -headers
    843  ffb5				  -	      ldx	#0
    844  ffb5				  -kn2	      lda	header,x
    845  ffb5				  -	      sta	$0f
    846  ffb5				  -	      lda	#$20
    847  ffb5				  -	      sta	$0f
    848  ffb5				  -	      inx
    849  ffb5				  -	      cpx	#9
    850  ffb5				  -	      bne	kn2
    851  ffb5				  -	      lda	#$0a
    852  ffb5				  -	      sta	$0f
    853  ffb5				  -	      rts
    854  ffb5				  -
    855  ffb5				  -header
    856  ffb5				  -	      .byte	$20,$41,$42,$43,$44,$45,$46,$47
    857  ffb5				  -	      .byte	$48
    858  ffb5				  -
    859  ffb5				  -letters
    860  ffb5				  -	      .byte	$2e,$70,$72,$62,$71,$6e,$6b,$00
    861  ffb5				  -	      .byte	$00,$50,$52,$42,$51,$4e,$4b
    862  ffb5				  -
    863  ffb5				  -			;
    864  ffb5				  -			; Read a coordinate choosen by cursor
    865  ffb5				  -			; Moves y to x, y contains new coordinate.
    866  ffb5				  -			;
    867  ffb5				  -read_coor
    868  ffb5				  -	      tya
    869  ffb5				  -	      tax
    870  ffb5				  -	      jsr	readkey
    871  ffb5				  -	      sta	even
    872  ffb5				  -	      jsr	readkey
    873  ffb5				  -	      eor	#$ff	; 1-8 converted to $fe-$f7
    874  ffb5				  -	      clc
    875  ffb5				  -	      adc	#$09	; row
    876  ffb5				  -	      asl		; x2
    877  ffb5				  -	      sta	bitmap0
    878  ffb5				  -	      asl		; x4
    879  ffb5				  -	      asl		; x8
    880  ffb5				  -	      adc	bitmap0	; x10
    881  ffb5				  -	      adc	even	; +column
    882  ffb5				  -	      tay
    883  ffb5				  -	      dey
    884  ffb5				  -	      rts
    885  ffb5				  -
    886  ffb5				  -readkey
    887  ffb5				  -	      lda	$d011
    888  ffb5				  -	      beq	readkey
    889  ffb5				  -	      lda	$d010
    890  ffb5				  -	      and	#$0f
    891  ffb5				  -	      rts
    892  ffb5				  -
    893  ffb5					      endif
    894  ffb5
    895  ffb5				   initial
    896  ffb5		       02 05 03 04*	      .byte.b	$02,$05,$03,$04,$06,$03,$05,$02
    897  ffbd
    898  ffbd				   scores
    899  ffbd		       00 01 05 03*	      .byte.b	0,1,5,3,9,3
    900  ffc3
    901  ffc3				   offsets
    902  ffc3		       10 14 08 0c*	      .byte.b	16,20,8,12,8,0,8
    903  ffca
    904  ffca				   displacement
    905  ffca		       eb ed f4 f8*	      .byte.b	-21,-19,-12,-8,8,12,19,21
    906  ffd2		       f6 0a ff 01	      .byte.b	-10,10,-1,1
    907  ffd6		       09 0b f7 f5	      .byte.b	9,11,-9,-11
    908  ffda		       f5 f7 f6 ec	      .byte.b	-11,-9,-10,-20
    909  ffde		       09 0b 0a 14	      .byte.b	9,11,10,20
    910  ffe2
    911  ffe2					      if	mode = atari
    912  ffe2
    913  ffe2				   pieces_color
    914  ffe2		       28 28 28 28	      .byte.b	color_black, color_black, color_black, color_black
    915  ffe6		       28 28 28 28	      .byte.b	color_black, color_black, color_black, color_black
    916  ffea		       0e 0e 0e 0e	      .byte.b	color_white, color_white, color_white, color_white
    917  ffee		       0e 0e 0e 	      .byte.b	color_white, color_white, color_white
    918  fff1
 Free bytes section 2 ($ff00-$fff7):  $7
    919  fff1					      echo	"Free bytes section 2 ($ff00-$fff7): ",$fff8-*
    920  fff1
    921  fff8					      org	$fff8
    922  fff8		       00 00 00 00	      .byte.b	0,0,0,0	; Avoid bank switching (Supercharger)
    923  fffc
    924  fffc		       00 fc		      .word.w	START	; RESET
    925  fffe		       00 fc		      .word.w	START	; BRK
    926  10000					       endif

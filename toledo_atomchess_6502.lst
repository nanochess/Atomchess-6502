------- FILE toledo_atomchess_6502.asm LEVEL 1 PASS 2
      1  10000 ????						;
      2  10000 ????						; Toledo Atomchess 6502 for Atari VCS/2600
      3  10000 ????						;
      4  10000 ????						; by Óscar Toledo G. (nanochess)
      5  10000 ????						;
      6  10000 ????						; © Copyright 2017 Óscar Toledo Gutiérrez
      7  10000 ????						;
      8  10000 ????						; Creation date: Jan/02/2017. Ported from Toledo Atomchess x86.
      9  10000 ????						; Revision date: Jan/04/2017. Working board display logic and selection.
     10  10000 ????						; Revision date: Jan/05/2017. Avoid player to move non-white pieces or
     11  10000 ????						;			       bug when fire bounces. Now using another
     12  10000 ????						;			       color for black pieces. Small optimization.
     13  10000 ????						; Revision date: Jan/13/2017. Solved bug where it would answer with move
     14  10000 ????						;			       after checkmate. Some more comments.
     15  10000 ????						; Revision date: Jan/15/2017. Added size optimizations by Peter Ferrie,
     16  10000 ????						;			       19 bytes saved. Also I've optimized my
     17  10000 ????						;			       graphical/input interface for further 18
     18  10000 ????						;			       bytes.
     19  10000 ????						; Revision date: Jan/16/2017. Saved 2 bytes more in playfield setup for
     20  10000 ????						;			       squares (Ferrie). Taken note of which
     21  10000 ????						;			       instructions can trigger the oVerflow flag.
     22  10000 ????						;			       Now can be assembled for visual6502.org
     23  10000 ????						;
     24  10000 ????
     25  10000 ????				       processor	6502
     26  10000 ????
     27  10000 ????		00 00	    atari      =	$00	; Define this to create an Atari VCS/2600 game (1K ROM)
     28  10000 ????		00 01	    visual6502 =	$01	; Define this to create a Visual6502.org playable game.
     29  10000 ????
     30  10000 ????						;
     31  10000 ????						; Change this to your preference.
     32  10000 ????						;
     33  10000 ????		00 00	    mode       =	atari
     34  10000 ????
     35  10000 ????						; Features:
     36  10000 ????						; * Computer plays legal basic chess movements ;)
     37  10000 ????						; * Move with joystick, push button to select, push button to drop.
     38  10000 ????						; * Search depth of 2-ply
     39  10000 ????						; * Promotion of pawns only to queen.
     40  10000 ????						; * No castling
     41  10000 ????						; * No en passant.
     42  10000 ????						; * 1K self-contained size for Hackaday
     43  10000 ????						;
     44  10000 ????						; Assemble with dasm from http://dasm-dillon.sourceforge.net/ 
     45  10000 ????						; Tested with Stella from http://stella.sourceforge.net/
     46  10000 ????						; Tested in real Atari 2600 using Harmony cartridge.
     47  10000 ????						; Tested with online emulation from http://8bitworkshop.com/
     48  10000 ????						; Demostration video at https://www.youtube.com/watch?v=_Du4krvIl7o
     49  10000 ????
     50  10000 ????				       if	mode = atari
     51  10000 ????
     52  fc00					      org	$fc00
     53  fc00		       00 00	   VSYNC      =	$00	; 0000 00x0   Vertical Sync Set-Clear
     54  fc00		       00 01	   VBLANK     =	$01	; xx00 00x0   Vertical Blank Set-Clear
     55  fc00		       00 02	   WSYNC      =	$02	; ---- ----   Wait for Horizontal Blank
     56  fc00		       00 03	   RSYNC      =	$03	; ---- ----   Reset Horizontal Sync Counter
     57  fc00		       00 04	   NUSIZ0     =	$04	; 00xx 0xxx   Number-Size player/missile 0
     58  fc00		       00 05	   NUSIZ1     =	$05	; 00xx 0xxx   Number-Size player/missile 1
     59  fc00		       00 06	   COLUP0     =	$06	; xxxx xxx0   Color-Luminance Player 0
     60  fc00		       00 07	   COLUP1     =	$07	; xxxx xxx0   Color-Luminance Player 1
     61  fc00		       00 08	   COLUPF     =	$08	; xxxx xxx0   Color-Luminance Playfield
     62  fc00		       00 09	   COLUBK     =	$09	; xxxx xxx0   Color-Luminance Background
     63  fc00		       00 0a	   CTRLPF     =	$0a	; 00xx 0xxx   Control Playfield, Ball, Collisions
     64  fc00		       00 0b	   REFP0      =	$0b	; 0000 x000   Reflection Player 0
     65  fc00		       00 0c	   REFP1      =	$0c	; 0000 x000   Reflection Player 1
     66  fc00		       00 0d	   PF0	      =	$0d	; xxxx 0000   Playfield Register Byte 0
     67  fc00		       00 0e	   PF1	      =	$0e	; xxxx xxxx   Playfield Register Byte 1
     68  fc00		       00 0f	   PF2	      =	$0f	; xxxx xxxx   Playfield Register Byte 2
     69  fc00		       00 10	   RESP0      =	$10	; ---- ----   Reset Player 0
     70  fc00		       00 11	   RESP1      =	$11	; ---- ----   Reset Player 1
     71  fc00		       00 12	   RESM0      =	$12	; ---- ----   Reset Missle 0
     72  fc00		       00 13	   RESM1      =	$13	; ---- ----   Reset Missle 1
     73  fc00		       00 14	   RESBL      =	$14	; ---- ----   Reset Ball
     74  fc00		       00 15	   AUDC0      =	$15	; 0000 xxxx   Audio Control 0
     75  fc00		       00 16	   AUDC1      =	$16	; 0000 xxxx   Audio Control 1
     76  fc00		       00 17	   AUDF0      =	$17	; 000x xxxx   Audio Frequency 0
     77  fc00		       00 18	   AUDF1      =	$18	; 000x xxxx   Audio Frequency 1
     78  fc00		       00 19	   AUDV0      =	$19	; 0000 xxxx   Audio Volume 0
     79  fc00		       00 1a	   AUDV1      =	$1a	; 0000 xxxx   Audio Volume 1
     80  fc00		       00 1b	   GRP0       =	$1b	; xxxx xxxx   Graphics Register Player 0
     81  fc00		       00 1c	   GRP1       =	$1c	; xxxx xxxx   Graphics Register Player 1
     82  fc00		       00 1d	   ENAM0      =	$1d	; 0000 00x0   Graphics Enable Missile 0
     83  fc00		       00 1e	   ENAM1      =	$1e	; 0000 00x0   Graphics Enable Missile 1
     84  fc00		       00 1f	   ENABL      =	$1f	; 0000 00x0   Graphics Enable Ball
     85  fc00		       00 20	   HMP0       =	$20	; xxxx 0000   Horizontal Motion Player 0
     86  fc00		       00 21	   HMP1       =	$21	; xxxx 0000   Horizontal Motion Player 1
     87  fc00		       00 22	   HMM0       =	$22	; xxxx 0000   Horizontal Motion Missile 0
     88  fc00		       00 23	   HMM1       =	$23	; xxxx 0000   Horizontal Motion Missile 1
     89  fc00		       00 24	   HMBL       =	$24	; xxxx 0000   Horizontal Motion Ball
     90  fc00		       00 25	   VDELP0     =	$25	; 0000 000x   Vertical Delay Player 0
     91  fc00		       00 26	   VDELP1     =	$26	; 0000 000x   Vertical Delay Player 1
     92  fc00		       00 27	   VDELBL     =	$27	; 0000 000x   Vertical Delay Ball
     93  fc00		       00 28	   RESMP0     =	$28	; 0000 00x0   Reset Missile 0 to Player 0
     94  fc00		       00 29	   RESMP1     =	$29	; 0000 00x0   Reset Missile 1 to Player 1
     95  fc00		       00 2a	   HMOVE      =	$2a	; ---- ----   Apply Horizontal Motion
     96  fc00		       00 2b	   HMCLR      =	$2b	; ---- ----   Clear Horizontal Move Registers
     97  fc00		       00 2c	   CXCLR      =	$2c	; ---- ----   Clear Collision Latches
     98  fc00
     99  fc00		       00 00	   CXM0P      =	$00	; xx00 0000	   Read Collision  M0-P1   M0-P0
    100  fc00		       00 01	   CXM1P      =	$01	; xx00 0000			   M1-P0   M1-P1
    101  fc00		       00 02	   CXP0FB     =	$02	; xx00 0000			   P0-PF   P0-BL
    102  fc00		       00 03	   CXP1FB     =	$03	; xx00 0000			   P1-PF   P1-BL
    103  fc00		       00 04	   CXM0FB     =	$04	; xx00 0000			   M0-PF   M0-BL
    104  fc00		       00 05	   CXM1FB     =	$05	; xx00 0000			   M1-PF   M1-BL
    105  fc00		       00 06	   CXBLPF     =	$06	; x000 0000			   BL-PF   -----
    106  fc00		       00 07	   CXPPMM     =	$07	; xx00 0000			   P0-P1   M0-M1
    107  fc00		       00 08	   INPT0      =	$08	; x000 0000	   Read Pot Port 0
    108  fc00		       00 09	   INPT1      =	$09	; x000 0000	   Read Pot Port 1
    109  fc00		       00 0a	   INPT2      =	$0a	; x000 0000	   Read Pot Port 2
    110  fc00		       00 0b	   INPT3      =	$0b	; x000 0000	   Read Pot Port 3
    111  fc00		       00 0c	   INPT4      =	$0c	; x000 0000	   Read Input (Trigger) 0
    112  fc00		       00 0d	   INPT5      =	$0d	; x000 0000	   Read Input (Trigger) 1
    113  fc00
    114  fc00							; RIOT MEMORY MAP
    115  fc00
    116  fc00		       02 80	   SWCHA      =	$280	; Port A data register for joysticks:
    117  fc00							; Bits 4-7 for player 1.  Bits 0-3 for player 2.
    118  fc00		       02 81	   SWACNT     =	$281	; Port A data direction register (DDR)
    119  fc00		       02 82	   SWCHB      =	$282	; Port B data (console switches)
    120  fc00		       02 83	   SWBCNT     =	$283	; Port B DDR
    121  fc00		       02 84	   INTIM      =	$284	; Timer output
    122  fc00
    123  fc00		       02 85	   TIMINT     =	$285
    124  fc00
    125  fc00		       02 94	   TIM1T      =	$294	; set 1 clock interval
    126  fc00		       02 95	   TIM8T      =	$295	; set 8 clock interval
    127  fc00		       02 96	   TIM64T     =	$296	; set 64 clock interval
    128  fc00		       02 97	   T1024T     =	$297	; set 1024 clock interval
    129  fc00
    130  fc00							;
    131  fc00							; These are colors for NTSC video, change for PAL
    132  fc00							;
    133  fc00		       00 0e	   color_white =	$0e	; Color for white pieces
    134  fc00		       00 28	   color_black =	$28	; Color for black pieces
    135  fc00		       00 74	   color_white_square =	$74	; Color for white squares
    136  fc00		       00 70	   color_black_square =	$70	; Color for black squares
    137  fc00
    138  fc00				  -	      else
    139  fc00				  -	      org	$0100
    140  fc00					      endif
    141  fc00
    142  fc00		       00 80	   score      =	$80	; Current score
    143  fc00		       00 81	   side       =	$81	; Current side
    144  fc00		       00 82	   offset     =	$82	; Current offset
    145  fc00		       00 83	   total      =	$83	; Current total
    146  fc00		       00 84	   origin     =	$84	; Current origin square
    147  fc00		       00 85	   target     =	$85	; Current target square
    148  fc00
    149  fc00		       00 86	   frame      =	$86	; Current frame
    150  fc00
    151  fc00		       00 87	   cursorx    =	$87	; Current X position of cursor
    152  fc00		       00 88	   cursory    =	$88	; Current Y position of cursor
    153  fc00
    154  fc00		       00 89	   pSWCHA     =	$89	; Previous value of SWCHA
    155  fc00		       00 8a	   pINPT4     =	$8A	; Previous value of INPT4
    156  fc00
    157  fc00							; Reused locations
    158  fc00		       00 82	   bitmap0    =	$82	; Index into bitmap (0)
    159  fc00		       00 83	   bitmap1    =	$83	; Index into bitmap (1)
    160  fc00		       00 81	   bitmap2    =	$81	; Index into bitmap (2)
    161  fc00		       00 8b	   bitmap3    =	$8b	; Index into bitmap (3)
    162  fc00		       00 80	   even       =	$80	; Marks even/odd
    163  fc00
    164  fc00		       00 8c	   board      =	$8c	; 78 bytes used, there should be space for 12+12+10 bytes of stack
    165  fc00
    166  fc00				   START
    167  fc00		       78		      sei		; Disable interruptions
    168  fc01		       d8		      cld		; Disable decimal mode
    169  fc02					      if	mode = atari
    170  fc02							; Clean up the memory
    171  fc02		       a9 00		      lda	#0	; Load zero in accumulator
    172  fc04		       aa		      tax		; ...copy in X
    173  fc05		       95 00	   sr0	      sta	0,X	; Save in address 0 plus X
    174  fc07		       9a		      txs		; Copy X in S (stack) last value will be $ff
    175  fc08		       e8		      inx		; Increment X
    176  fc09		       d0 fa		      bne	sr0	; Repeat until X is zero.
    177  fc0b
    178  fc0b		       8d 81 02 	      sta	SWACNT	; Allow to read joysticks
    179  fc0e		       8d 83 02 	      sta	SWBCNT	; Allow to read buttons
    180  fc11							;	 ldx #0       ; x is zero
    181  fc11				  -	      else
    182  fc11				  -			; Clean up the memory
    183  fc11				  -	      ldx	#$ff
    184  fc11				  -	      txs
    185  fc11				  -	      lda	#$00	; Load zero in accumulator
    186  fc11				  -	      ldx	#$80	; ...copy in X
    187  fc11				  -sr0	      sta	0,X	; Save in address 0 plus X
    188  fc11				  -	      inx		; Increment X
    189  fc11				  -	      cpx	#$8c
    190  fc11				  -	      bne	sr0	; Repeat until X is zero.
    191  fc11				  -	      tax		; x is zero
    192  fc11					      endif
    193  fc11
    194  fc11		       a0 08	   sr1	      ldy	#8
    195  fc13		       a9 00	   sr3	      lda	#$00
    196  fc15		       95 8c		      sta	board,x
    197  fc17		       e8		      inx
    198  fc18		       88		      dey
    199  fc19		       d0 f8		      bne	sr3
    200  fc1b		       a9 07		      lda	#$07
    201  fc1d		       95 8c		      sta	board,x
    202  fc1f		       e8		      inx
    203  fc20		       95 8c		      sta	board,x
    204  fc22		       e8		      inx
    205  fc23		       e0 50		      cpx	#8*10
    206  fc25		       d0 ea		      bne	sr1
    207  fc27		       aa		      tax		; a was $07, so x = $07
    208  fc28		       bd bc ff    sr2	      lda	initial,x
    209  fc2b		       95 8c		      sta	board,x
    210  fc2d		       09 08		      ora	#$08
    211  fc2f		       95 d2		      sta	board+70,x
    212  fc31		       f6 96		      inc	board+10,x
    213  fc33		       a9 09		      lda	#$09
    214  fc35		       95 c8		      sta	board+60,x
    215  fc37		       ca		      dex
    216  fc38		       10 ee		      bpl	sr2
    217  fc3a		       4a		      lsr		; lda #4, but A was $09 / 2 = $04
    218  fc3b		       85 87		      sta	cursorx
    219  fc3d		       85 88		      sta	cursory
    220  fc3f
    221  fc3f							;
    222  fc3f							; Main loop
    223  fc3f							;
    224  fc3f				   sr21
    225  fc3f					      if	mode = atari
    226  fc3f				  -	      else
    227  fc3f				  -	      jsr	kernel
    228  fc3f					      endif
    229  fc3f		       20 ab ff 	      jsr	read_coor
    230  fc42		       b9 8c 00 	      lda	board,y
    231  fc45		       29 08		      and	#8	; Check for white piece
    232  fc47		       f0 f6		      beq	sr21	; If no, jump and restart selection logic
    233  fc49		       20 ab ff    sr11       jsr	read_coor
    234  fc4c		       b9 8c 00 	      lda	board,y
    235  fc4f		       29 08		      and	#8	; Check for white piece
    236  fc51		       d0 f6		      bne	sr11	; If yes, restart target square logic
    237  fc53		       20 87 fc 	      jsr	sr28	; Make movement
    238  fc56					      if	mode = atari
    239  fc56		       a2 3f		      ldx	#63
    240  fc58		       8a	   kn0	      txa
    241  fc59		       4a		      lsr
    242  fc5a		       4a		      lsr
    243  fc5b		       85 19		      sta	AUDV0
    244  fc5d		       8a		      txa
    245  fc5e		       48		      pha
    246  fc5f		       20 a4 fd 	      jsr	kernel
    247  fc62		       68		      pla
    248  fc63		       aa		      tax
    249  fc64		       ca		      dex
    250  fc65		       d0 f1		      bne	kn0
    251  fc67				  -	      else
    252  fc67				  -	      jsr	kernel
    253  fc67					      endif
    254  fc67		       20 a3 fc 	      jsr	play	; Computer play
    255  fc6a		       4c 3f fc 	      jmp	sr21
    256  fc6d
    257  fc6d		       e6 82	   sr14       inc	offset
    258  fc6f		       c6 83		      dec	total
    259  fc71		       d0 58		      bne	sr12
    260  fc73		       e8	   sr17       inx
    261  fc74		       e0 4e		      cpx	#78
    262  fc76		       d0 33		      bne	sr7
    263  fc78		       68		      pla
    264  fc79		       a8		      tay
    265  fc7a		       68		      pla
    266  fc7b		       ba		      tsx
    267  fc7c		       e0 fd		      cpx	#$ff-2	; Top call? (2 bytes of return address)
    268  fc7e		       d0 22		      bne	sr24
    269  fc80		       a6 80		      ldx	score
    270  fc82		       e0 d3		      cpx	#$c0+19	; Illegal move? (always in check)
    271  fc84		       30 1c		      bmi	sr24	; Yes, doesn't move
    272  fc86		       aa		      tax
    273  fc87		       b5 8c	   sr28       lda	board,x	; Do move
    274  fc89		       c9 01		      cmp	#1
    275  fc8b		       f0 04		      beq	sr32
    276  fc8d		       c9 09		      cmp	#9	; Is it pawn?
    277  fc8f		       d0 0a		      bne	sr30
    278  fc91		       c0 0a	   sr32       cpy	#10	; Reaching border?
    279  fc93		       90 04		      bcc	sr31
    280  fc95		       c0 46		      cpy	#70
    281  fc97		       90 02		      bcc	sr30
    282  fc99		       49 05	   sr31       eor	#5	; Make it queen
    283  fc9b		       99 8c 00    sr30       sta	board,y
    284  fc9e		       a9 00		      lda	#0	; Clear origin square
    285  fca0		       95 8c		      sta	board,x
    286  fca2		       60	   sr24       rts
    287  fca3
    288  fca3							;
    289  fca3							; Computer plays :)
    290  fca3							;
    291  fca3		       a9 c0	   play       lda	#$c0	; Current score (-64)
    292  fca5		       85 80		      sta	score
    293  fca7		       48		      pha		; Origin square of best movement (currently none)
    294  fca8		       48		      pha		; Target square of best movement
    295  fca9		       a2 00		      ldx	#0	; x points to current square
    296  fcab		       b5 8c	   sr7	      lda	board,x	; Read square
    297  fcad		       f0 c4		      beq	sr17	; Ignore if empty square
    298  fcaf		       45 81		      eor	side	; XOR with current playing side
    299  fcb1		       c9 07		      cmp	#7	; Ignore if frontier
    300  fcb3		       b0 be		      bcs	sr17
    301  fcb5		       c9 01		      cmp	#1	; Is it pawn?
    302  fcb7		       d0 06		      bne	sr25	; Carry will be 1 always because 1<=A<=6
    303  fcb9		       a4 81		      ldy	side	; Is it playing black?
    304  fcbb		       f0 02		      beq	sr25	; Yes, jump
    305  fcbd		       a9 00		      lda	#0	; Make it zero for white
    306  fcbf		       a8	   sr25       tay
    307  fcc0		       69 03		      adc	#3	; Adds 4 because carry is 1 (see above)
    308  fcc2		       29 0c		      and	#$0c
    309  fcc4		       85 83		      sta	total	; Total movements of piece
    310  fcc6		       b9 ca ff 	      lda	offsets,y
    311  fcc9		       85 82		      sta	offset	; Next offset for movement
    312  fccb		       86 85	   sr12       stx	target	; Restart target square
    313  fccd		       a4 82	   sr9	      ldy	offset
    314  fccf		       b9 d1 ff 	      lda	displacement,y
    315  fcd2		       18		      clc
    316  fcd3		       65 85		      adc	target	; Next target square
    317  fcd5		       c9 4e		      cmp	#78	; Out of board?
    318  fcd7		       b0 94		      bcs	sr14
    319  fcd9		       85 85		      sta	target
    320  fcdb
    321  fcdb		       c0 10		      cpy	#16
    322  fcdd		       a8		      tay
    323  fcde		       b9 8c 00 	      lda	board,y	; Content of target square
    324  fce1		       f0 26		      beq	sr10	; Jump if empty square
    325  fce3		       90 06		      bcc	sr27	; Jump if isn't not pawn
    326  fce5		       a5 83		      lda	total
    327  fce7		       c9 03		      cmp	#3	; Straight?
    328  fce9		       90 88		      bcc	sr17	; Yes, avoid and cancels any double square movement
    329  fceb		       b9 8c 00    sr27       lda	board,y
    330  fcee		       45 81		      eor	side
    331  fcf0		       38		      sec
    332  fcf1		       e9 09		      sbc	#9	; Valid capture?
    333  fcf3		       c9 06		      cmp	#6
    334  fcf5		       b0 1a		      bcs	sr29	; No, avoid (too far for sr18, use sr29 as bridge)
    335  fcf7		       c9 05		      cmp	#5
    336  fcf9		       d0 23		      bne	sr20	; Jump if not captured king
    337  fcfb		       68		      pla		; Ignore values
    338  fcfc		       68		      pla
    339  fcfd		       ba		      tsx
    340  fcfe		       a9 2d		      lda	#$3f-18	; Maximum score minus two queens...
    341  fd00		       e0 f1		      cpx	#$f1	; ...if not in first response.
    342  fd02		       d0 02		      bne	sr26
    343  fd04		       a9 3f		      lda	#$3f	; Maximum score (probably checkmate/stalemate)
    344  fd06		       85 80	   sr26       sta	score
    345  fd08		       60		      rts
    346  fd09
    347  fd09		       90 13	   sr10       bcc	sr20	; If isn't pawn, jump.
    348  fd0b		       a5 83		      lda	total
    349  fd0d		       c9 02		      cmp	#2	; Diagonal?
    350  fd0f		       f0 04		      beq	sr15	; Jump if one square ahead
    351  fd11		       b0 7a	   sr29       bcs	sr18	; Yes, avoid
    352  fd13		       90 09		      bcc	sr20
    353  fd15
    354  fd15		       8a	   sr15       txa
    355  fd16							;sec		 ; Carry set already because equality comparison
    356  fd16		       e9 14		      sbc	#20
    357  fd18		       c9 28		      cmp	#40	; Moving from center of board?
    358  fd1a		       b0 02		      bcs	sr20
    359  fd1c		       c6 83		      dec	total	; Yes, then avoid checking for two squares
    360  fd1e							;bcc sr20	 ; Fall along
    361  fd1e
    362  fd1e							; Save all state
    363  fd1e		       a5 82	   sr20       lda	offset	; Offset for movement
    364  fd20		       48		      pha
    365  fd21		       a5 83		      lda	total	; Total directions left
    366  fd23		       48		      pha
    367  fd24		       b9 8c 00 	      lda	board,y	; Content of target square
    368  fd27		       48		      pha
    369  fd28		       98		      tya		; Target square
    370  fd29		       48		      pha
    371  fd2a		       b5 8c		      lda	board,x	; Content of origin square
    372  fd2c		       48		      pha
    373  fd2d		       8a		      txa		; Origin square
    374  fd2e		       85 84		      sta	origin
    375  fd30		       48		      pha
    376  fd31		       b9 8c 00 	      lda	board,y
    377  fd34		       29 07		      and	#7
    378  fd36		       a8		      tay
    379  fd37		       b9 c4 ff 	      lda	scores,y	; Score for capture
    380  fd3a		       ba		      tsx
    381  fd3b					      if	mode = atari
    382  fd3b		       e0 e2		      cpx	#255-10*3+1	; Depth limit (2-ply)
    383  fd3d				  -	      else
    384  fd3d				  -	      cpx	#255-10*2+1	; Depth limit (1-ply)
    385  fd3d					      endif
    386  fd3d		       90 22		      bcc	sr22
    387  fd3f		       48		      pha
    388  fd40		       a5 80		      lda	score	; Current score
    389  fd42		       48		      pha
    390  fd43		       a6 84		      ldx	origin
    391  fd45		       a4 85		      ldy	target
    392  fd47		       20 87 fc 	      jsr	sr28	; Do move
    393  fd4a		       a5 81		      lda	side
    394  fd4c		       49 08		      eor	#8	; Change side
    395  fd4e		       85 81		      sta	side
    396  fd50		       20 a3 fc 	      jsr	play
    397  fd53		       a5 81		      lda	side
    398  fd55		       49 08		      eor	#8	; Change side
    399  fd57		       85 81		      sta	side
    400  fd59		       68		      pla
    401  fd5a		       aa		      tax		; Current score in x
    402  fd5b		       68		      pla
    403  fd5c		       38		      sec		; Take capture score and substract adversary score
    404  fd5d		       e5 80		      sbc	score
    405  fd5f		       86 80		      stx	score	; Restore current score
    406  fd61		       c5 80	   sr22       cmp	score	; Better score?
    407  fd63		       18		      clc
    408  fd64		       30 0c		      bmi	sr23	; No, jump
    409  fd66		       d0 07		      bne	sr33	; Better score? yes, jump
    410  fd68		       a5 86		      lda	frame	; Equal score, randomize move
    411  fd6a		       6a		      ror
    412  fd6b		       6a		      ror
    413  fd6c		       4c 72 fd 	      jmp	sr23	; No need to update score but carry = 1 will update move
    414  fd6f							;bcc sr23
    415  fd6f							;bcs sr23
    416  fd6f		       85 80	   sr33       sta	score	; Update score
    417  fd71		       38		      sec
    418  fd72		       68	   sr23       pla		; Restore board
    419  fd73		       aa		      tax
    420  fd74		       68		      pla
    421  fd75		       95 8c		      sta	board,x
    422  fd77		       68		      pla
    423  fd78		       85 85		      sta	target
    424  fd7a		       a8		      tay
    425  fd7b		       68		      pla
    426  fd7c		       99 8c 00 	      sta	board,y
    427  fd7f		       68		      pla
    428  fd80		       85 83		      sta	total
    429  fd82		       68		      pla
    430  fd83		       85 82		      sta	offset
    431  fd85		       90 06		      bcc	sr18
    432  fd87		       68		      pla
    433  fd88		       68		      pla
    434  fd89		       8a		      txa		; Save current best movement
    435  fd8a		       48		      pha
    436  fd8b		       98		      tya
    437  fd8c		       48		      pha
    438  fd8d
    439  fd8d		       b5 8c	   sr18       lda	board,x
    440  fd8f		       29 07		      and	#7
    441  fd91		       c9 01		      cmp	#1	; Was it pawn?
    442  fd93		       f0 0c		      beq	sr16	; Yes, end sequence, choose next movement
    443  fd95		       c9 05		      cmp	#5	; Knight or king?
    444  fd97		       b0 08		      bcs	sr16	; End sequence, choose next movement
    445  fd99		       b9 8c 00 	      lda	board,y	; To empty square?
    446  fd9c		       d0 03		      bne	sr16
    447  fd9e		       4c cd fc 	      jmp	sr9	; Yes, follow line of squares
    448  fda1
    449  fda1		       4c 6d fc    sr16       jmp	sr14
    450  fda4
    451  fda4					      if	mode = atari
    452  fda4							;
    453  fda4							; Set object in X
    454  fda4							; A = X position
    455  fda4							; First arg = Object to position (0=P0, 1=P1, 2=M0, 3=M1, 4=BALL)
    456  fda4							; Exits with carry = 0, it can set V flag for X >= 128
    457  fda4							;
    458  fda4					      MAC	set_x_position
    459  fda4					      sta	WSYNC	; 0- Start line synchro
    460  fda4					      sec		; 3- Set carry flag (avoids it in loop)
    461  fda4				   .AE2       sbc	#15	; 5- Uses required time dividing A by 15
    462  fda4					      bcs	.AE2	; 7/8 - 9/14/19/24/29/34/39/44/49/54/59/64
    463  fda4					      tay		; 9
    464  fda4					      lda	fine_adjustment-$f1,y	; 11 - Eats 5 cycles crossing page
    465  fda4					      sta	HMP0+{1}	; 16
    466  fda4					      nop		; 19
    467  fda4					      sta	RESP0+{1}	; 21/26/31/36/41/46/51/56/61/66/71 - "big" positioning
    468  fda4					      ENDM
    469  fda4
    470  fda4							;
    471  fda4							; Display kernel
    472  fda4							;
    473  fda4				   kernel
    474  fda4		       a9 00		      lda	#$00
    475  fda6		       85 09		      sta	COLUBK	; Background color
    476  fda8
    477  fda8							; VERTICAL_SYNC
    478  fda8		       a2 02		      ldx	#2
    479  fdaa		       86 00		      stx	VSYNC	; Start vertical synchro
    480  fdac		       86 02		      stx	WSYNC	; Wait for 3 lines
    481  fdae		       86 02		      stx	WSYNC
    482  fdb0		       86 02		      stx	WSYNC
    483  fdb2							;
    484  fdb2		       a2 2b		      ldx	#43
    485  fdb4		       8e 96 02 	      stx	TIM64T
    486  fdb7		       85 00		      sta	VSYNC	; Stop vertical synchro
    487  fdb9		       85 1b		      sta	GRP0
    488  fdbb		       85 1c		      sta	GRP1
    489  fdbd		       a9 70		      lda	#color_black_square
    490  fdbf		       85 09		      sta	COLUBK	; Background color
    491  fdc1		       a9 35		      lda	#$35
    492  fdc3		       85 04		      sta	NUSIZ0	; Size of player/missile 0
    493  fdc5		       85 05		      sta	NUSIZ1	; Size of player/missile 1
    494  fdc7		       a9 74		      lda	#color_white_square
    495  fdc9		       85 08		      sta	COLUPF	; Color of playfield
    496  fdcb		       a5 87		      lda	cursorx	; Get X-position of cursor and set up missile 0
    497  fdcd		       0a		      asl
    498  fdce		       0a		      asl
    499  fdcf		       85 80		      sta	even
    500  fdd1		       0a		      asl
    501  fdd2		       0a		      asl
    502  fdd3		       65 80		      adc	even	; Can set V flag for eighth square (cursorx = 7)
    503  fdd5		       69 0e		      adc	#14
    504  fdd7		       c9 0e		      cmp	#14
    505  fdd9		       d0 02		      bne	*+4
    506  fddb		       e9 03		      sbc	#3
      0  fddd					      set_x_position	2
      1  fddd		       85 02		      sta	WSYNC
      2  fddf		       38		      sec
      3  fde0		       e9 0f	   .AE2       sbc	#15
      4  fde2		       b0 fc		      bcs	.AE2
      5  fde4		       a8		      tay
      6  fde5		       b9 ab fe 	      lda	fine_adjustment-$f1,y
      7  fde8		       85 22		      sta	HMP0+2
      8  fdea		       ea		      nop
      9  fdeb		       85 12		      sta	RESP0+2
    508  fded		       85 02		      sta	WSYNC
    509  fdef		       85 2a		      sta	HMOVE	; Fine adjustment for all set_x_position
    510  fdf1
    511  fdf1				   wait_vblank
    512  fdf1		       ad 84 02 	      lda	INTIM
    513  fdf4		       d0 fb		      bne	wait_vblank
    514  fdf6							;
    515  fdf6							; Start of graphics
    516  fdf6							;
    517  fdf6		       85 02		      sta	WSYNC
    518  fdf8		       85 01		      sta	VBLANK
    519  fdfa		       85 80		      sta	even	; Now uses like row counter, start at zero
    520  fdfc		       a5 86		      lda	frame	; Board position per frame
    521  fdfe		       29 01		      and	#1
    522  fe00		       0a		      asl
    523  fe01		       aa	   ds0	      tax
    524  fe02		       85 02	   ds1	      sta	WSYNC	; Row 0
    525  fe04		       a5 80		      lda	even	; Squares configuration over board
    526  fe06		       4a		      lsr
    527  fe07		       90 0a		      bcc	ds6
    528  fe09		       a9 00		      lda	#$00
    529  fe0b		       85 0d		      sta	PF0
    530  fe0d		       a0 7c		      ldy	#$7c
    531  fe0f		       a9 f8		      lda	#$f8
    532  fe11		       d0 08		      bne	ds7
    533  fe13
    534  fe13		       a9 f0	   ds6	      lda	#$f0
    535  fe15		       85 0d		      sta	PF0
    536  fe17		       a0 83		      ldy	#$83
    537  fe19		       a9 07		      lda	#$07
    538  fe1b		       84 0e	   ds7	      sty	PF1
    539  fe1d		       85 0f		      sta	PF2
    540  fe1f		       b5 8c		      lda	board,x	; Bitmap for piece
    541  fe21		       29 07		      and	#7
    542  fe23		       0a		      asl
    543  fe24		       0a		      asl
    544  fe25		       0a		      asl
    545  fe26		       85 82		      sta	bitmap0
    546  fe28		       85 02		      sta	WSYNC	; Row 1
    547  fe2a		       a5 80		      lda	even	; Check if row...
    548  fe2c		       c5 88		      cmp	cursory	; ...equals row of cursor
    549  fe2e		       08		      php		; Save Z flag...
    550  fe2f		       68		      pla		; ...so it goes to bit 1
    551  fe30		       85 1d		      sta	ENAM0	; Enable missile if at right Y position
    552  fe32		       b5 8d		      lda	board+1,x
    553  fe34		       29 07		      and	#7
    554  fe36		       0a		      asl
    555  fe37		       0a		      asl
    556  fe38		       0a		      asl		; //Carry is zero after this instruction
    557  fe39		       85 83		      sta	bitmap1
    558  fe3b		       85 02		      sta	WSYNC
    559  fe3d		       b5 90		      lda	board+4,x	; Bitmap for piece
    560  fe3f		       29 07		      and	#7
    561  fe41		       0a		      asl
    562  fe42		       0a		      asl
    563  fe43		       0a		      asl
    564  fe44		       85 81		      sta	bitmap2
    565  fe46		       85 02		      sta	WSYNC
    566  fe48		       b5 91		      lda	board+5,x	; Bitmap for piece
    567  fe4a		       29 07		      and	#7
    568  fe4c		       0a		      asl
    569  fe4d		       0a		      asl
    570  fe4e		       0a		      asl
    571  fe4f		       85 8b		      sta	bitmap3
    572  fe51		       85 02		      sta	WSYNC	; 0
    573  fe53		       a5 86		      lda	frame	; 3
    574  fe55		       a5 86		      lda	frame	; 6
    575  fe57		       a5 86		      lda	frame	; 9
    576  fe59		       4a		      lsr		; 14
    577  fe5a		       a0 03		      ldy	#3	; 12
    578  fe5c		       90 6a		      bcc	ds9	; 16
    579  fe5e		       a0 02		      ldy	#2	; 18
    580  fe60		       88	   ds10       dey		; 20/25
    581  fe61		       d0 fd		      bne	ds10
    582  fe63		       a5 82		      lda	bitmap0	; 29
    583  fe65		       a5 82		      lda	bitmap0	; 32
    584  fe67		       85 10		      sta	RESP0	; 35
    585  fe69		       a5 82		      lda	bitmap0	; 38
    586  fe6b		       85 11		      sta	RESP1	; 41
    587  fe6d
    588  fe6d				   ds11
    589  fe6d		       b4 8c		      ldy	board,x	; 54 Check color for the two pieces
    590  fe6f		       b9 e9 ff 	      lda	pieces_color,y	; 58
    591  fe72		       85 06		      sta	COLUP0	; 62
    592  fe74		       b4 8d		      ldy	board+1,x	; 65 Check color for the two pieces
    593  fe76		       b9 e9 ff 	      lda	pieces_color,y	; 69
    594  fe79		       85 07		      sta	COLUP1	; 73
    595  fe7b
    596  fe7b		       85 02		      sta	WSYNC
    597  fe7d		       a4 82		      ldy	bitmap0	; 3
    598  fe7f		       b9 64 ff 	      lda	pieces,y	; 6
    599  fe82		       85 1b		      sta	GRP0	; 10
    600  fe84		       a4 83		      ldy	bitmap1	; 13
    601  fe86		       b9 64 ff 	      lda	pieces,y	; 22
    602  fe89		       85 1c		      sta	GRP1	; 31
    603  fe8b		       e6 82		      inc	bitmap0	; 34
    604  fe8d		       e6 83		      inc	bitmap1	; 39
    605  fe8f		       ea		      nop
    606  fe90		       85 10		      sta	RESP0	; 19
    607  fe92		       a5 82		      lda	bitmap0	; 26
    608  fe94		       85 11		      sta	RESP1	; 28
    609  fe96
    610  fe96		       b4 90		      ldy	board+4,x	; 44 Check color for the two pieces
    611  fe98		       b9 e9 ff 	      lda	pieces_color,y	; 48
    612  fe9b		       85 06		      sta	COLUP0	; 52
    613  fe9d		       b4 91		      ldy	board+5,x	; 55 Check color for the two pieces
    614  fe9f		       b9 e9 ff 	      lda	pieces_color,y	; 59
    615  fea2		       85 07		      sta	COLUP1	; 63
    616  fea4
    617  fea4		       85 02		      sta	WSYNC
    618  fea6		       a4 81		      ldy	bitmap2	; 3 
    619  fea8		       b9 64 ff 	      lda	pieces,y	; 6
    620  feab		       85 1b		      sta	GRP0	; 10
    621  fead		       a4 8b		      ldy	bitmap3	; 13
    622  feaf		       b9 64 ff 	      lda	pieces,y	; 16
    623  feb2		       38		      sec		; 20
    624  feb3		       85 1c		      sta	GRP1	; 22
    625  feb5		       e6 81		      inc	bitmap2	; 25
    626  feb7		       e6 8b		      inc	bitmap3	; 30
    627  feb9		       85 14		      sta	RESBL	; 35
    628  febb		       a5 82		      lda	bitmap0	; 38
    629  febd		       85 14		      sta	RESBL	; 41
    630  febf		       29 07		      and	#7	; 44
    631  fec1		       e9 07		      sbc	#7	; 46
    632  fec3		       d0 a8		      bne	ds11	; 48 + 3
    633  fec5		       4c 29 ff 	      jmp	ds12
    634  fec8
    635  fec8		       85 10	   ds9	      sta	RESP0	; 19
    636  feca		       ea		      nop		; 22
    637  fecb		       ea		      nop		; 24
    638  fecc		       ea		      nop		; 26
    639  fecd		       85 11		      sta	RESP1	; 28
    640  fecf
    641  fecf				   ds3
    642  fecf		       b4 8c		      ldy	board,x	; 54 Check color for the two pieces
    643  fed1		       b9 e9 ff 	      lda	pieces_color,y	; 58
    644  fed4		       85 06		      sta	COLUP0	; 62
    645  fed6		       b4 8d		      ldy	board+1,x	; 65 Check color for the two pieces
    646  fed8		       b9 e9 ff 	      lda	pieces_color,y	; 69
    647  fedb		       85 07		      sta	COLUP1	; 73
    648  fedd
    649  fedd		       85 02		      sta	WSYNC
    650  fedf		       a4 82		      ldy	bitmap0	; 3
    651  fee1		       b9 64 ff 	      lda	pieces,y	; 6
    652  fee4		       85 1b		      sta	GRP0	; 10
    653  fee6		       a4 83		      ldy	bitmap1	; 13
    654  fee8		       b9 64 ff 	      lda	pieces,y	; 16
    655  feeb		       85 1c		      sta	GRP1	; 20
    656  feed		       e6 82		      inc	bitmap0	; 23
    657  feef		       e6 83		      inc	bitmap1	; 28
    658  fef1		       ea		      nop		; 33
    659  fef2		       b4 90		      ldy	board+4,x	; 35 Check color for the two pieces
    660  fef4		       b9 e9 ff 	      lda	pieces_color,y	; 39
    661  fef7		       85 06		      sta	COLUP0	; 43
    662  fef9		       ea		      nop		; 46
    663  fefa		       85 10		      sta	RESP0	; 48
    664  fefc		       a5 82		      lda	bitmap0	; 51
    665  fefe		       85 11		      sta	RESP1	; 54
    666  ff00		       b4 91		      ldy	board+5,x	; 57 Check color for the two pieces
    667  ff02		       b9 e9 ff 	      lda	pieces_color,y	; 61
    668  ff05		       85 07		      sta	COLUP1	; 65
    669  ff07
    670  ff07		       85 02		      sta	WSYNC
    671  ff09		       a4 81		      ldy	bitmap2	; 3 
    672  ff0b		       b9 64 ff 	      lda	pieces,y	; 6
    673  ff0e		       85 1b		      sta	GRP0	; 10
    674  ff10		       85 1b		      sta	GRP0	; 13
    675  ff12		       a4 8b		      ldy	bitmap3	; 16
    676  ff14		       85 10		      sta	RESP0	; 19
    677  ff16		       b9 64 ff 	      lda	pieces,y	; 22
    678  ff19		       38		      sec		; 26
    679  ff1a		       85 11		      sta	RESP1	; 28
    680  ff1c		       85 1c		      sta	GRP1	; 31
    681  ff1e		       e6 81		      inc	bitmap2	; 34
    682  ff20		       e6 8b		      inc	bitmap3	; 39
    683  ff22		       98		      tya		; 44
    684  ff23		       29 07		      and	#7	; 47
    685  ff25		       e9 06		      sbc	#6	; 49
    686  ff27		       d0 a6		      bne	ds3	; 51 + 3
    687  ff29				   ds12
    688  ff29		       85 02		      sta	WSYNC
    689  ff2b		       85 1d		      sta	ENAM0	; Disable cursor
    690  ff2d		       85 02		      sta	WSYNC
    691  ff2f		       85 02		      sta	WSYNC
    692  ff31		       85 02		      sta	WSYNC
    693  ff33		       e6 80		      inc	even	; Increase current row
    694  ff35		       8a		      txa
    695  ff36		       18		      clc		; Carry is still zero//
    696  ff37		       69 0a		      adc	#10	; Next row of board
    697  ff39		       c9 50		      cmp	#80
    698  ff3b		       b0 03		      bcs	ds8
    699  ff3d		       4c 01 fe 	      jmp	ds0
    700  ff40				   ds8
    701  ff40
    702  ff40							;
    703  ff40							; End of graphics (204 lines)
    704  ff40							;
    705  ff40		       85 02		      sta	WSYNC
    706  ff42		       a9 02		      lda	#2
    707  ff44		       85 02		      sta	WSYNC
    708  ff46		       85 01		      sta	VBLANK
    709  ff48
    710  ff48							;
    711  ff48							; Start overscan timer
    712  ff48							;
    713  ff48		       a9 2b		      lda	#43	; 37 lines * 76 = 2812 cycles / 64 = 43.9375
    714  ff4a		       8d 96 02 	      sta	TIM64T
    715  ff4d				   wait_overscan
    716  ff4d		       ad 84 02 	      lda	INTIM
    717  ff50		       d0 fb		      bne	wait_overscan
    718  ff52		       85 02		      sta	WSYNC
    719  ff54		       85 0d		      sta	PF0
    720  ff56		       85 0e		      sta	PF1
    721  ff58		       85 0f		      sta	PF2
    722  ff5a		       85 02		      sta	WSYNC
    723  ff5c		       85 81		      sta	side	; Black side plays
    724  ff5e
    725  ff5e		       e6 86		      inc	frame
    726  ff60
    727  ff60		       60		      rts
    728  ff61
 Free bytes section 1:  $ffffffbf
    729  ff61					      echo	"Free bytes section 1: ",$ff20-*
    730  ff61
    731  ff64					      org	$ff64
    732  ff64				   pieces
    733  ff64		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00
    734  ff6c		       00 18 3c 3c*	      .byte.b	$00,$18,$3c,$3c,$18,$3c,$00,$00
    735  ff74		       5a 7e 3c 3c*	      .byte.b	$5a,$7e,$3c,$3c,$7e,$7e,$00,$00
    736  ff7c		       18 3c 3c 3c*	      .byte.b	$18,$3c,$3c,$3c,$18,$66,$00,$00
    737  ff84		       5a 5a 24 3c*	      .byte.b	$5a,$5a,$24,$3c,$3c,$3c,$00,$00
    738  ff8c		       70 58 7c 6e*	      .byte.b	$70,$58,$7c,$6e,$1e,$3e,$00,$00
    739  ff94		       3c 6a 56 3c*	      .byte.b	$3c,$6a,$56,$3c,$3c,$3c,$00,$00
    740  ff9c
    741  ff9c				   fine_adjustment
    742  ff9c		       70		      .byte.b	$70	; -7 
    743  ff9d		       60		      .byte.b	$60	; -6 
    744  ff9e		       50		      .byte.b	$50	; -5
    745  ff9f		       40		      .byte.b	$40	; -4
    746  ffa0		       30		      .byte.b	$30	; -3
    747  ffa1		       20		      .byte.b	$20	; -2
    748  ffa2		       10		      .byte.b	$10	; -1
    749  ffa3		       00		      .byte.b	$00	; 0
    750  ffa4		       f0		      .byte.b	$f0	; +1
    751  ffa5		       e0		      .byte.b	$e0	; +2
    752  ffa6		       d0		      .byte.b	$d0	; +3
    753  ffa7		       c0		      .byte.b	$c0	; +4
    754  ffa8		       b0		      .byte.b	$b0	; +5
    755  ffa9		       a0		      .byte.b	$a0	; +6
    756  ffaa		       90		      .byte.b	$90	; +7
    757  ffab
    758  ffab							;
    759  ffab							; Read a coordinate choosen by cursor
    760  ffab							; Moves y to x, y contains new coordinate.
    761  ffab							;
    762  ffab				   read_coor
    763  ffab		       98		      tya
    764  ffac		       48		      pha
    765  ffad		       20 b6 ff 	      jsr	read_coor2
    766  ffb0		       a8		      tay
    767  ffb1		       68		      pla
    768  ffb2		       aa		      tax
    769  ffb3		       60		      rts
    770  ffb4
    771  ffb4		       a0 00	   rc5	      ldy	#0
    772  ffb6				  -	      if	0
    773  ffb6				  -	      lda	SWCHA	; Read current state of joystick
    774  ffb6				  -	      sta	even
    775  ffb6				  -	      tax
    776  ffb6				  -	      eor	pSWCHA
    777  ffb6				  -	      stx	pSWCHA
    778  ffb6				  -	      eor	#$ff
    779  ffb6				  -	      ora	even	; Disable unchanged directions
    780  ffb6				  -	      bmi	rc0	; Jump if not going right
    781  ffb6				  -	      ldx	cursorx
    782  ffb6				  -	      cpx	#7
    783  ffb6				  -	      beq	rc0
    784  ffb6				  -	      inc	cursorx
    785  ffb6				  -	      ldy	#8
    786  ffb6				  -
    787  ffb6				  -rc0	      rol		; Jump if not going left
    788  ffb6				  -	      bmi	rc1
    789  ffb6				  -	      ldx	cursorx
    790  ffb6				  -	      beq	rc1
    791  ffb6				  -	      dec	cursorx
    792  ffb6				  -	      ldy	#8
    793  ffb6				  -
    794  ffb6				  -rc1	      rol		; Jump if not going down
    795  ffb6				  -	      bmi	rc2
    796  ffb6				  -	      ldx	cursory
    797  ffb6				  -	      cpx	#7
    798  ffb6				  -	      beq	rc2
    799  ffb6				  -	      inc	cursory
    800  ffb6				  -	      ldy	#8
    801  ffb6				  -
    802  ffb6				  -rc2	      rol		; Jump if not going up
    803  ffb6				  -	      bmi	rc3
    804  ffb6				  -	      ldx	cursory
    805  ffb6				  -	      beq	rc3
    806  ffb6				  -	      dec	cursory
    807  ffb6				  -	      ldy	#8
    808  ffb6				  -rc3
    809  ffb6				  -	      ldx	#$01
    810  ffb6				  -	      stx	AUDC0
    811  ffb6				  -	      sty	AUDV0
    812  ffb6				  -	      sty	AUDF0
    813  ffb6					      endif
    814  ffb6							;	 jmp read_coor2     ; Fall thru
    815  ffb6							;
    816  ffb6							; Read a coordinate in a
    817  ffb6							;
    818  ffb6				   read_coor2
    819  ffb6		       20 a4 fd 	      jsr	kernel
    820  ffb9		       4c b4 ff 	      jmp	rc5
    821  ffbc				  -	      if	0
    822  ffbc				  -			;lda #0	    ; Kernel returns with a = 0
    823  ffbc				  -	      sta	AUDV0
    824  ffbc				  -	      lda	INPT4	; Read current state of button
    825  ffbc				  -	      sta	even
    826  ffbc				  -	      tax
    827  ffbc				  -	      eor	pINPT4
    828  ffbc				  -	      stx	pINPT4
    829  ffbc				  -	      eor	#$ff
    830  ffbc				  -	      ora	even	; Disable unchanged button
    831  ffbc				  -	      bmi	rc5	; Jump if button not pressed
    832  ffbc				  -			;
    833  ffbc				  -			; Computer plays
    834  ffbc				  -			;
    835  ffbc				  -	      ldx	#$03
    836  ffbc				  -	      stx	AUDC0
    837  ffbc				  -	      ldx	#$08
    838  ffbc				  -	      stx	AUDV0
    839  ffbc				  -	      stx	AUDF0
    840  ffbc				  -	      lda	cursory	; y_coor 
    841  ffbc				  -	      asl		; *2
    842  ffbc				  -	      asl		; *4
    843  ffbc				  -	      adc	cursory	; *5
    844  ffbc				  -	      asl		; *10
    845  ffbc				  -	      adc	cursorx	; + x_coor
    846  ffbc				  -	      rts
    847  ffbc					      endif
    848  ffbc
    849  ffbc				  -	      else
    850  ffbc				  -kernel
    851  ffbc				  -	      jsr	headers
    852  ffbc				  -	      lda	#$38
    853  ffbc				  -	      sta	bitmap0
    854  ffbc				  -	      ldx	#0
    855  ffbc				  -kn0	      lda	bitmap0
    856  ffbc				  -	      sta	$0f
    857  ffbc				  -	      lda	#$20
    858  ffbc				  -	      sta	$0f
    859  ffbc				  -	      ldy	#8
    860  ffbc				  -kn1	      txa
    861  ffbc				  -	      pha
    862  ffbc				  -	      lda	board,x
    863  ffbc				  -	      tax
    864  ffbc				  -	      lda	letters,x
    865  ffbc				  -	      sta	$0f
    866  ffbc				  -	      lda	#$20
    867  ffbc				  -	      sta	$0f
    868  ffbc				  -	      pla
    869  ffbc				  -	      tax
    870  ffbc				  -	      inx
    871  ffbc				  -	      dey
    872  ffbc				  -	      bne	kn1
    873  ffbc				  -	      lda	bitmap0
    874  ffbc				  -	      sta	$0f
    875  ffbc				  -	      lda	#$0a
    876  ffbc				  -	      sta	$0f
    877  ffbc				  -	      dec	bitmap0
    878  ffbc				  -	      inx
    879  ffbc				  -	      inx
    880  ffbc				  -	      cpx	#80
    881  ffbc				  -	      bne	kn0
    882  ffbc				  -	      jsr	headers
    883  ffbc				  -	      rts
    884  ffbc				  -
    885  ffbc				  -headers
    886  ffbc				  -	      ldx	#0
    887  ffbc				  -kn2	      lda	header,x
    888  ffbc				  -	      sta	$0f
    889  ffbc				  -	      lda	#$20
    890  ffbc				  -	      sta	$0f
    891  ffbc				  -	      inx
    892  ffbc				  -	      cpx	#9
    893  ffbc				  -	      bne	kn2
    894  ffbc				  -	      lda	#$0a
    895  ffbc				  -	      sta	$0f
    896  ffbc				  -	      rts
    897  ffbc				  -
    898  ffbc				  -header
    899  ffbc				  -	      .byte	$20,$41,$42,$43,$44,$45,$46,$47
    900  ffbc				  -	      .byte	$48
    901  ffbc				  -
    902  ffbc				  -letters
    903  ffbc				  -	      .byte	$2e,$70,$72,$62,$71,$6e,$6b,$00
    904  ffbc				  -	      .byte	$00,$50,$52,$42,$51,$4e,$4b
    905  ffbc				  -
    906  ffbc				  -			;
    907  ffbc				  -			; Read a coordinate choosen by cursor
    908  ffbc				  -			; Moves y to x, y contains new coordinate.
    909  ffbc				  -			;
    910  ffbc				  -read_coor
    911  ffbc				  -	      tya
    912  ffbc				  -	      tax
    913  ffbc				  -	      jsr	readkey
    914  ffbc				  -	      sta	even
    915  ffbc				  -	      jsr	readkey
    916  ffbc				  -	      eor	#$ff	; 1-8 converted to $fe-$f7
    917  ffbc				  -	      clc
    918  ffbc				  -	      adc	#$09	; row
    919  ffbc				  -	      asl		; x2
    920  ffbc				  -	      sta	bitmap0
    921  ffbc				  -	      asl		; x4
    922  ffbc				  -	      asl		; x8
    923  ffbc				  -	      adc	bitmap0	; x10
    924  ffbc				  -	      adc	even	; +column
    925  ffbc				  -	      tay
    926  ffbc				  -	      dey
    927  ffbc				  -	      rts
    928  ffbc				  -
    929  ffbc				  -readkey
    930  ffbc				  -	      lda	$d011
    931  ffbc				  -	      beq	readkey
    932  ffbc				  -	      lda	$d010
    933  ffbc				  -	      and	#$0f
    934  ffbc				  -	      rts
    935  ffbc				  -
    936  ffbc					      endif
    937  ffbc
    938  ffbc				   initial
    939  ffbc		       02 05 03 04*	      .byte.b	$02,$05,$03,$04,$06,$03,$05,$02
    940  ffc4
    941  ffc4				   scores
    942  ffc4		       00 01 05 03*	      .byte.b	0,1,5,3,9,3
    943  ffca
    944  ffca				   offsets
    945  ffca		       10 14 08 0c*	      .byte.b	16,20,8,12,8,0,8
    946  ffd1
    947  ffd1				   displacement
    948  ffd1		       eb ed f4 f8*	      .byte.b	-21,-19,-12,-8,8,12,19,21
    949  ffd9		       f6 0a ff 01	      .byte.b	-10,10,-1,1
    950  ffdd		       09 0b f7 f5	      .byte.b	9,11,-9,-11
    951  ffe1		       f5 f7 f6 ec	      .byte.b	-11,-9,-10,-20
    952  ffe5		       09 0b 0a 14	      .byte.b	9,11,10,20
    953  ffe9
    954  ffe9					      if	mode = atari
    955  ffe9
    956  ffe9				   pieces_color
    957  ffe9		       28 28 28 28	      .byte.b	color_black, color_black, color_black, color_black
    958  ffed		       28 28 28 28	      .byte.b	color_black, color_black, color_black, color_black
    959  fff1		       0e 0e 0e 0e	      .byte.b	color_white, color_white, color_white, color_white
    960  fff5		       0e 0e 0e 	      .byte.b	color_white, color_white, color_white
    961  fff8
 Free bytes section 2:  $4
    962  fff8					      echo	"Free bytes section 2: ",$fffc-*
    963  fff8
    964  fffc					      org	$fffc
    965  fffc		       00 fc		      .word.w	START	; RESET
    966  fffe		       00 fc		      .word.w	START	; BRK
    967  10000					       endif

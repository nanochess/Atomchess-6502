------- FILE toledo_atomchess_6502.asm LEVEL 1 PASS 2
      1  10000 ????						;
      2  10000 ????						; Toledo Atomchess 6502 for Atari VCS/2600
      3  10000 ????						;
      4  10000 ????						; by Óscar Toledo G. (nanochess)
      5  10000 ????						;
      6  10000 ????						; © Copyright 2017 Óscar Toledo Gutiérrez
      7  10000 ????						;
      8  10000 ????						; Creation date: Jan/02/2017. Ported from Toledo Atomchess x86.
      9  10000 ????						; Revision date: Jan/04/2017. Working board display logic and selection.
     10  10000 ????						; Revision date: Jan/05/2017. Avoid player to move non-white pieces or
     11  10000 ????						;			       bug when fire bounces. Now using another
     12  10000 ????						;			       color for black pieces. Small optimization.
     13  10000 ????						; Revision date: Jan/13/2017. Solved bug where it would answer with move
     14  10000 ????						;			       after checkmate. Some more comments.
     15  10000 ????						; Revision date: Jan/15/2017. Added size optimizations by Peter Ferrie,
     16  10000 ????						;			       19 bytes saved. Also I've optimized my
     17  10000 ????						;			       graphical/input interface for further 18
     18  10000 ????						;			       bytes.
     19  10000 ????						; Revision date: Jan/16/2017. Saved 2 bytes more in playfield setup for
     20  10000 ????						;			       squares (Ferrie). Taken note of which
     21  10000 ????						;			       instructions can trigger the oVerflow flag.
     22  10000 ????						;			       Now can be assembled for visual6502.org
     23  10000 ????						; Revision date: Jul/08/2017. Redesigned display code to use venetian blinds
     24  10000 ????						;			       technique in Atari VCS display, it allows for
     25  10000 ????						;			       30hz flicker so pieces will look steady.
     26  10000 ????						;
     27  10000 ????
     28  10000 ????				       processor	6502
     29  10000 ????
     30  10000 ????		00 00	    atari      =	$00	; Define this to create an Atari VCS/2600 game (1K ROM)
     31  10000 ????		00 01	    visual6502 =	$01	; Define this to create a Visual6502.org playable game.
     32  10000 ????
     33  10000 ????						;
     34  10000 ????						; Change this to your preference.
     35  10000 ????						;
     36  10000 ????		00 00	    mode       =	atari
     37  10000 ????
     38  10000 ????						; Features:
     39  10000 ????						; * Computer plays legal basic chess movements ;)
     40  10000 ????						; * Move with joystick, push button to select, push button to drop.
     41  10000 ????						; * Search depth of 2-ply
     42  10000 ????						; * Promotion of pawns only to queen.
     43  10000 ????						; * No castling
     44  10000 ????						; * No en passant.
     45  10000 ????						; * 1K self-contained size for Hackaday
     46  10000 ????						;
     47  10000 ????						; Assemble with dasm from http://dasm-dillon.sourceforge.net/ 
     48  10000 ????						; Tested with Stella from http://stella.sourceforge.net/
     49  10000 ????						; Tested in real Atari 2600 using Harmony cartridge.
     50  10000 ????						; Tested with online emulation from http://8bitworkshop.com/
     51  10000 ????						; Demostration video at https://www.youtube.com/watch?v=_Du4krvIl7o
     52  10000 ????
     53  10000 ????				       if	mode = atari
     54  10000 ????
     55  fc00					      org	$fc00
     56  fc00		       00 00	   VSYNC      =	$00	; 0000 00x0   Vertical Sync Set-Clear
     57  fc00		       00 01	   VBLANK     =	$01	; xx00 00x0   Vertical Blank Set-Clear
     58  fc00		       00 02	   WSYNC      =	$02	; ---- ----   Wait for Horizontal Blank
     59  fc00		       00 03	   RSYNC      =	$03	; ---- ----   Reset Horizontal Sync Counter
     60  fc00		       00 04	   NUSIZ0     =	$04	; 00xx 0xxx   Number-Size player/missile 0
     61  fc00		       00 05	   NUSIZ1     =	$05	; 00xx 0xxx   Number-Size player/missile 1
     62  fc00		       00 06	   COLUP0     =	$06	; xxxx xxx0   Color-Luminance Player 0
     63  fc00		       00 07	   COLUP1     =	$07	; xxxx xxx0   Color-Luminance Player 1
     64  fc00		       00 08	   COLUPF     =	$08	; xxxx xxx0   Color-Luminance Playfield
     65  fc00		       00 09	   COLUBK     =	$09	; xxxx xxx0   Color-Luminance Background
     66  fc00		       00 0a	   CTRLPF     =	$0a	; 00xx 0xxx   Control Playfield, Ball, Collisions
     67  fc00		       00 0b	   REFP0      =	$0b	; 0000 x000   Reflection Player 0
     68  fc00		       00 0c	   REFP1      =	$0c	; 0000 x000   Reflection Player 1
     69  fc00		       00 0d	   PF0	      =	$0d	; xxxx 0000   Playfield Register Byte 0
     70  fc00		       00 0e	   PF1	      =	$0e	; xxxx xxxx   Playfield Register Byte 1
     71  fc00		       00 0f	   PF2	      =	$0f	; xxxx xxxx   Playfield Register Byte 2
     72  fc00		       00 10	   RESP0      =	$10	; ---- ----   Reset Player 0
     73  fc00		       00 11	   RESP1      =	$11	; ---- ----   Reset Player 1
     74  fc00		       00 12	   RESM0      =	$12	; ---- ----   Reset Missle 0
     75  fc00		       00 13	   RESM1      =	$13	; ---- ----   Reset Missle 1
     76  fc00		       00 14	   RESBL      =	$14	; ---- ----   Reset Ball
     77  fc00		       00 15	   AUDC0      =	$15	; 0000 xxxx   Audio Control 0
     78  fc00		       00 16	   AUDC1      =	$16	; 0000 xxxx   Audio Control 1
     79  fc00		       00 17	   AUDF0      =	$17	; 000x xxxx   Audio Frequency 0
     80  fc00		       00 18	   AUDF1      =	$18	; 000x xxxx   Audio Frequency 1
     81  fc00		       00 19	   AUDV0      =	$19	; 0000 xxxx   Audio Volume 0
     82  fc00		       00 1a	   AUDV1      =	$1a	; 0000 xxxx   Audio Volume 1
     83  fc00		       00 1b	   GRP0       =	$1b	; xxxx xxxx   Graphics Register Player 0
     84  fc00		       00 1c	   GRP1       =	$1c	; xxxx xxxx   Graphics Register Player 1
     85  fc00		       00 1d	   ENAM0      =	$1d	; 0000 00x0   Graphics Enable Missile 0
     86  fc00		       00 1e	   ENAM1      =	$1e	; 0000 00x0   Graphics Enable Missile 1
     87  fc00		       00 1f	   ENABL      =	$1f	; 0000 00x0   Graphics Enable Ball
     88  fc00		       00 20	   HMP0       =	$20	; xxxx 0000   Horizontal Motion Player 0
     89  fc00		       00 21	   HMP1       =	$21	; xxxx 0000   Horizontal Motion Player 1
     90  fc00		       00 22	   HMM0       =	$22	; xxxx 0000   Horizontal Motion Missile 0
     91  fc00		       00 23	   HMM1       =	$23	; xxxx 0000   Horizontal Motion Missile 1
     92  fc00		       00 24	   HMBL       =	$24	; xxxx 0000   Horizontal Motion Ball
     93  fc00		       00 25	   VDELP0     =	$25	; 0000 000x   Vertical Delay Player 0
     94  fc00		       00 26	   VDELP1     =	$26	; 0000 000x   Vertical Delay Player 1
     95  fc00		       00 27	   VDELBL     =	$27	; 0000 000x   Vertical Delay Ball
     96  fc00		       00 28	   RESMP0     =	$28	; 0000 00x0   Reset Missile 0 to Player 0
     97  fc00		       00 29	   RESMP1     =	$29	; 0000 00x0   Reset Missile 1 to Player 1
     98  fc00		       00 2a	   HMOVE      =	$2a	; ---- ----   Apply Horizontal Motion
     99  fc00		       00 2b	   HMCLR      =	$2b	; ---- ----   Clear Horizontal Move Registers
    100  fc00		       00 2c	   CXCLR      =	$2c	; ---- ----   Clear Collision Latches
    101  fc00
    102  fc00		       00 00	   CXM0P      =	$00	; xx00 0000	   Read Collision  M0-P1   M0-P0
    103  fc00		       00 01	   CXM1P      =	$01	; xx00 0000			   M1-P0   M1-P1
    104  fc00		       00 02	   CXP0FB     =	$02	; xx00 0000			   P0-PF   P0-BL
    105  fc00		       00 03	   CXP1FB     =	$03	; xx00 0000			   P1-PF   P1-BL
    106  fc00		       00 04	   CXM0FB     =	$04	; xx00 0000			   M0-PF   M0-BL
    107  fc00		       00 05	   CXM1FB     =	$05	; xx00 0000			   M1-PF   M1-BL
    108  fc00		       00 06	   CXBLPF     =	$06	; x000 0000			   BL-PF   -----
    109  fc00		       00 07	   CXPPMM     =	$07	; xx00 0000			   P0-P1   M0-M1
    110  fc00		       00 08	   INPT0      =	$08	; x000 0000	   Read Pot Port 0
    111  fc00		       00 09	   INPT1      =	$09	; x000 0000	   Read Pot Port 1
    112  fc00		       00 0a	   INPT2      =	$0a	; x000 0000	   Read Pot Port 2
    113  fc00		       00 0b	   INPT3      =	$0b	; x000 0000	   Read Pot Port 3
    114  fc00		       00 0c	   INPT4      =	$0c	; x000 0000	   Read Input (Trigger) 0
    115  fc00		       00 0d	   INPT5      =	$0d	; x000 0000	   Read Input (Trigger) 1
    116  fc00
    117  fc00							; RIOT MEMORY MAP
    118  fc00
    119  fc00		       02 80	   SWCHA      =	$280	; Port A data register for joysticks:
    120  fc00							; Bits 4-7 for player 1.  Bits 0-3 for player 2.
    121  fc00		       02 81	   SWACNT     =	$281	; Port A data direction register (DDR)
    122  fc00		       02 82	   SWCHB      =	$282	; Port B data (console switches)
    123  fc00		       02 83	   SWBCNT     =	$283	; Port B DDR
    124  fc00		       02 84	   INTIM      =	$284	; Timer output
    125  fc00
    126  fc00		       02 85	   TIMINT     =	$285
    127  fc00
    128  fc00		       02 94	   TIM1T      =	$294	; set 1 clock interval
    129  fc00		       02 95	   TIM8T      =	$295	; set 8 clock interval
    130  fc00		       02 96	   TIM64T     =	$296	; set 64 clock interval
    131  fc00		       02 97	   T1024T     =	$297	; set 1024 clock interval
    132  fc00
    133  fc00							;
    134  fc00							; These are colors for NTSC video, change for PAL
    135  fc00							;
    136  fc00		       00 0e	   color_white =	$0e	; Color for white pieces
    137  fc00		       00 28	   color_black =	$28	; Color for black pieces
    138  fc00		       00 74	   color_white_square =	$74	; Color for white squares
    139  fc00		       00 70	   color_black_square =	$70	; Color for black squares
    140  fc00
    141  fc00				  -	      else
    142  fc00				  -	      org	$0100
    143  fc00					      endif
    144  fc00
    145  fc00		       00 80	   score      =	$80	; Current score
    146  fc00		       00 81	   side       =	$81	; Current side
    147  fc00		       00 82	   offset     =	$82	; Current offset
    148  fc00		       00 83	   total      =	$83	; Current total
    149  fc00		       00 84	   origin     =	$84	; Current origin square
    150  fc00		       00 85	   target     =	$85	; Current target square
    151  fc00
    152  fc00		       00 86	   frame      =	$86	; Current frame
    153  fc00
    154  fc00		       00 87	   cursorx    =	$87	; Current X position of cursor
    155  fc00		       00 88	   cursory    =	$88	; Current Y position of cursor
    156  fc00
    157  fc00		       00 89	   pSWCHA     =	$89	; Previous value of SWCHA
    158  fc00		       00 8a	   pINPT4     =	$8A	; Previous value of INPT4
    159  fc00
    160  fc00							; Reused locations
    161  fc00		       00 82	   bitmap0    =	$82	; Index into bitmap (0)
    162  fc00		       00 83	   bitmap1    =	$83	; Index into bitmap (1)
    163  fc00		       00 81	   bitmap2    =	$81	; Index into bitmap (2)
    164  fc00		       00 8b	   bitmap3    =	$8b	; Index into bitmap (3)
    165  fc00		       00 80	   even       =	$80	; Marks even/odd
    166  fc00
    167  fc00		       00 8c	   board      =	$8c	; 78 bytes used, there should be space for 12+12+10 bytes of stack
    168  fc00
    169  fc00				   START
    170  fc00		       78		      sei		; Disable interruptions
    171  fc01		       d8		      cld		; Disable decimal mode
    172  fc02					      if	mode = atari
    173  fc02							; Clean up the memory
    174  fc02		       a9 00		      lda	#0	; Load zero in accumulator
    175  fc04		       aa		      tax		; ...copy in X
    176  fc05		       95 00	   sr0	      sta	0,X	; Save in address 0 plus X
    177  fc07		       9a		      txs		; Copy X in S (stack) last value will be $ff
    178  fc08		       e8		      inx		; Increment X
    179  fc09		       d0 fa		      bne	sr0	; Repeat until X is zero.
    180  fc0b
    181  fc0b		       8d 81 02 	      sta	SWACNT	; Allow to read joysticks
    182  fc0e		       8d 83 02 	      sta	SWBCNT	; Allow to read buttons
    183  fc11							;	 ldx #0       ; x is zero
    184  fc11				  -	      else
    185  fc11				  -			; Clean up the memory
    186  fc11				  -	      ldx	#$ff
    187  fc11				  -	      txs
    188  fc11				  -	      lda	#$00	; Load zero in accumulator
    189  fc11				  -	      ldx	#$80	; ...copy in X
    190  fc11				  -sr0	      sta	0,X	; Save in address 0 plus X
    191  fc11				  -	      inx		; Increment X
    192  fc11				  -	      cpx	#$8c
    193  fc11				  -	      bne	sr0	; Repeat until X is zero.
    194  fc11				  -	      tax		; x is zero
    195  fc11					      endif
    196  fc11
    197  fc11		       a0 08	   sr1	      ldy	#8
    198  fc13		       a9 00	   sr3	      lda	#$00
    199  fc15		       95 8c		      sta	board,x
    200  fc17		       e8		      inx
    201  fc18		       88		      dey
    202  fc19		       d0 f8		      bne	sr3
    203  fc1b		       a9 07		      lda	#$07
    204  fc1d		       95 8c		      sta	board,x
    205  fc1f		       e8		      inx
    206  fc20		       95 8c		      sta	board,x
    207  fc22		       e8		      inx
    208  fc23		       e0 50		      cpx	#8*10
    209  fc25		       d0 ea		      bne	sr1
    210  fc27		       aa		      tax		; a was $07, so x = $07
    211  fc28		       bd bf ff    sr2	      lda	initial,x
    212  fc2b		       95 8c		      sta	board,x
    213  fc2d		       09 08		      ora	#$08
    214  fc2f		       95 d2		      sta	board+70,x
    215  fc31		       f6 96		      inc	board+10,x
    216  fc33		       a9 09		      lda	#$09
    217  fc35		       95 c8		      sta	board+60,x
    218  fc37		       ca		      dex
    219  fc38		       10 ee		      bpl	sr2
    220  fc3a		       4a		      lsr		; lda #4, but A was $09 / 2 = $04
    221  fc3b		       85 87		      sta	cursorx
    222  fc3d		       85 88		      sta	cursory
    223  fc3f
    224  fc3f							;
    225  fc3f							; Main loop
    226  fc3f							;
    227  fc3f				   sr21
    228  fc3f					      if	mode = atari
    229  fc3f				  -	      else
    230  fc3f				  -	      jsr	kernel
    231  fc3f					      endif
    232  fc3f		       20 47 ff 	      jsr	read_coor
    233  fc42		       b9 8c 00 	      lda	board,y
    234  fc45		       29 08		      and	#8	; Check for white piece
    235  fc47		       f0 f6		      beq	sr21	; If no, jump and restart selection logic
    236  fc49		       20 47 ff    sr11       jsr	read_coor
    237  fc4c		       b9 8c 00 	      lda	board,y
    238  fc4f		       29 08		      and	#8	; Check for white piece
    239  fc51		       d0 f6		      bne	sr11	; If yes, restart target square logic
    240  fc53		       20 87 fc 	      jsr	sr28	; Make movement
    241  fc56					      if	mode = atari
    242  fc56		       a2 3f		      ldx	#63
    243  fc58		       8a	   kn0	      txa
    244  fc59		       4a		      lsr
    245  fc5a		       4a		      lsr
    246  fc5b		       85 19		      sta	AUDV0
    247  fc5d		       8a		      txa
    248  fc5e		       48		      pha
    249  fc5f		       20 a4 fd 	      jsr	kernel
    250  fc62		       68		      pla
    251  fc63		       aa		      tax
    252  fc64		       ca		      dex
    253  fc65		       d0 f1		      bne	kn0
    254  fc67				  -	      else
    255  fc67				  -	      jsr	kernel
    256  fc67					      endif
    257  fc67		       20 a3 fc 	      jsr	play	; Computer play
    258  fc6a		       4c 3f fc 	      jmp	sr21
    259  fc6d
    260  fc6d		       e6 82	   sr14       inc	offset
    261  fc6f		       c6 83		      dec	total
    262  fc71		       d0 58		      bne	sr12
    263  fc73		       e8	   sr17       inx
    264  fc74		       e0 4e		      cpx	#78
    265  fc76		       d0 33		      bne	sr7
    266  fc78		       68		      pla
    267  fc79		       a8		      tay
    268  fc7a		       68		      pla
    269  fc7b		       ba		      tsx
    270  fc7c		       e0 fd		      cpx	#$ff-2	; Top call? (2 bytes of return address)
    271  fc7e		       d0 22		      bne	sr24
    272  fc80		       a6 80		      ldx	score
    273  fc82		       e0 d3		      cpx	#$c0+19	; Illegal move? (always in check)
    274  fc84		       30 1c		      bmi	sr24	; Yes, doesn't move
    275  fc86		       aa		      tax
    276  fc87		       b5 8c	   sr28       lda	board,x	; Do move
    277  fc89		       c9 01		      cmp	#1
    278  fc8b		       f0 04		      beq	sr32
    279  fc8d		       c9 09		      cmp	#9	; Is it pawn?
    280  fc8f		       d0 0a		      bne	sr30
    281  fc91		       c0 0a	   sr32       cpy	#10	; Reaching border?
    282  fc93		       90 04		      bcc	sr31
    283  fc95		       c0 46		      cpy	#70
    284  fc97		       90 02		      bcc	sr30
    285  fc99		       49 05	   sr31       eor	#5	; Make it queen
    286  fc9b		       99 8c 00    sr30       sta	board,y
    287  fc9e		       a9 00		      lda	#0	; Clear origin square
    288  fca0		       95 8c		      sta	board,x
    289  fca2		       60	   sr24       rts
    290  fca3
    291  fca3							;
    292  fca3							; Computer plays :)
    293  fca3							;
    294  fca3		       a9 c0	   play       lda	#$c0	; Current score (-64)
    295  fca5		       85 80		      sta	score
    296  fca7		       48		      pha		; Origin square of best movement (currently none)
    297  fca8		       48		      pha		; Target square of best movement
    298  fca9		       a2 00		      ldx	#0	; x points to current square
    299  fcab		       b5 8c	   sr7	      lda	board,x	; Read square
    300  fcad		       f0 c4		      beq	sr17	; Ignore if empty square
    301  fcaf		       45 81		      eor	side	; XOR with current playing side
    302  fcb1		       c9 07		      cmp	#7	; Ignore if frontier
    303  fcb3		       b0 be		      bcs	sr17
    304  fcb5		       c9 01		      cmp	#1	; Is it pawn?
    305  fcb7		       d0 06		      bne	sr25	; Carry will be 1 always because 1<=A<=6
    306  fcb9		       a4 81		      ldy	side	; Is it playing black?
    307  fcbb		       f0 02		      beq	sr25	; Yes, jump
    308  fcbd		       a9 00		      lda	#0	; Make it zero for white
    309  fcbf		       a8	   sr25       tay
    310  fcc0		       69 03		      adc	#3	; Adds 4 because carry is 1 (see above)
    311  fcc2		       29 0c		      and	#$0c
    312  fcc4		       85 83		      sta	total	; Total movements of piece
    313  fcc6		       b9 cd ff 	      lda	offsets,y
    314  fcc9		       85 82		      sta	offset	; Next offset for movement
    315  fccb		       86 85	   sr12       stx	target	; Restart target square
    316  fccd		       a4 82	   sr9	      ldy	offset
    317  fccf		       b9 d4 ff 	      lda	displacement,y
    318  fcd2		       18		      clc
    319  fcd3		       65 85		      adc	target	; Next target square
    320  fcd5		       c9 4e		      cmp	#78	; Out of board?
    321  fcd7		       b0 94		      bcs	sr14
    322  fcd9		       85 85		      sta	target
    323  fcdb
    324  fcdb		       c0 10		      cpy	#16
    325  fcdd		       a8		      tay
    326  fcde		       b9 8c 00 	      lda	board,y	; Content of target square
    327  fce1		       f0 26		      beq	sr10	; Jump if empty square
    328  fce3		       90 06		      bcc	sr27	; Jump if isn't not pawn
    329  fce5		       a5 83		      lda	total
    330  fce7		       c9 03		      cmp	#3	; Straight?
    331  fce9		       90 88		      bcc	sr17	; Yes, avoid and cancels any double square movement
    332  fceb		       b9 8c 00    sr27       lda	board,y
    333  fcee		       45 81		      eor	side
    334  fcf0		       38		      sec
    335  fcf1		       e9 09		      sbc	#9	; Valid capture?
    336  fcf3		       c9 06		      cmp	#6
    337  fcf5		       b0 1a		      bcs	sr29	; No, avoid (too far for sr18, use sr29 as bridge)
    338  fcf7		       c9 05		      cmp	#5
    339  fcf9		       d0 23		      bne	sr20	; Jump if not captured king
    340  fcfb		       68		      pla		; Ignore values
    341  fcfc		       68		      pla
    342  fcfd		       ba		      tsx
    343  fcfe		       a9 2d		      lda	#$3f-18	; Maximum score minus two queens...
    344  fd00		       e0 f1		      cpx	#$f1	; ...if not in first response.
    345  fd02		       d0 02		      bne	sr26
    346  fd04		       a9 3f		      lda	#$3f	; Maximum score (probably checkmate/stalemate)
    347  fd06		       85 80	   sr26       sta	score
    348  fd08		       60		      rts
    349  fd09
    350  fd09		       90 13	   sr10       bcc	sr20	; If isn't pawn, jump.
    351  fd0b		       a5 83		      lda	total
    352  fd0d		       c9 02		      cmp	#2	; Diagonal?
    353  fd0f		       f0 04		      beq	sr15	; Jump if one square ahead
    354  fd11		       b0 7a	   sr29       bcs	sr18	; Yes, avoid
    355  fd13		       90 09		      bcc	sr20
    356  fd15
    357  fd15		       8a	   sr15       txa
    358  fd16							;sec		 ; Carry set already because equality comparison
    359  fd16		       e9 14		      sbc	#20
    360  fd18		       c9 28		      cmp	#40	; Moving from center of board?
    361  fd1a		       b0 02		      bcs	sr20
    362  fd1c		       c6 83		      dec	total	; Yes, then avoid checking for two squares
    363  fd1e							;bcc sr20	 ; Fall along
    364  fd1e
    365  fd1e							; Save all state
    366  fd1e		       a5 82	   sr20       lda	offset	; Offset for movement
    367  fd20		       48		      pha
    368  fd21		       a5 83		      lda	total	; Total directions left
    369  fd23		       48		      pha
    370  fd24		       b9 8c 00 	      lda	board,y	; Content of target square
    371  fd27		       48		      pha
    372  fd28		       98		      tya		; Target square
    373  fd29		       48		      pha
    374  fd2a		       b5 8c		      lda	board,x	; Content of origin square
    375  fd2c		       48		      pha
    376  fd2d		       8a		      txa		; Origin square
    377  fd2e		       85 84		      sta	origin
    378  fd30		       48		      pha
    379  fd31		       b9 8c 00 	      lda	board,y
    380  fd34		       29 07		      and	#7
    381  fd36		       a8		      tay
    382  fd37		       b9 c7 ff 	      lda	scores,y	; Score for capture
    383  fd3a		       ba		      tsx
    384  fd3b					      if	mode = atari
    385  fd3b		       e0 e2		      cpx	#255-10*3+1	; Depth limit (2-ply)
    386  fd3d				  -	      else
    387  fd3d				  -	      cpx	#255-10*2+1	; Depth limit (1-ply)
    388  fd3d					      endif
    389  fd3d		       90 22		      bcc	sr22
    390  fd3f		       48		      pha
    391  fd40		       a5 80		      lda	score	; Current score
    392  fd42		       48		      pha
    393  fd43		       a6 84		      ldx	origin
    394  fd45		       a4 85		      ldy	target
    395  fd47		       20 87 fc 	      jsr	sr28	; Do move
    396  fd4a		       a5 81		      lda	side
    397  fd4c		       49 08		      eor	#8	; Change side
    398  fd4e		       85 81		      sta	side
    399  fd50		       20 a3 fc 	      jsr	play
    400  fd53		       a5 81		      lda	side
    401  fd55		       49 08		      eor	#8	; Change side
    402  fd57		       85 81		      sta	side
    403  fd59		       68		      pla
    404  fd5a		       aa		      tax		; Current score in x
    405  fd5b		       68		      pla
    406  fd5c		       38		      sec		; Take capture score and substract adversary score
    407  fd5d		       e5 80		      sbc	score
    408  fd5f		       86 80		      stx	score	; Restore current score
    409  fd61		       c5 80	   sr22       cmp	score	; Better score?
    410  fd63		       18		      clc
    411  fd64		       30 0c		      bmi	sr23	; No, jump
    412  fd66		       d0 07		      bne	sr33	; Better score? yes, jump
    413  fd68		       a5 86		      lda	frame	; Equal score, randomize move
    414  fd6a		       6a		      ror
    415  fd6b		       6a		      ror
    416  fd6c		       4c 72 fd 	      jmp	sr23	; No need to update score but carry = 1 will update move
    417  fd6f							;bcc sr23
    418  fd6f							;bcs sr23
    419  fd6f		       85 80	   sr33       sta	score	; Update score
    420  fd71		       38		      sec
    421  fd72		       68	   sr23       pla		; Restore board
    422  fd73		       aa		      tax
    423  fd74		       68		      pla
    424  fd75		       95 8c		      sta	board,x
    425  fd77		       68		      pla
    426  fd78		       85 85		      sta	target
    427  fd7a		       a8		      tay
    428  fd7b		       68		      pla
    429  fd7c		       99 8c 00 	      sta	board,y
    430  fd7f		       68		      pla
    431  fd80		       85 83		      sta	total
    432  fd82		       68		      pla
    433  fd83		       85 82		      sta	offset
    434  fd85		       90 06		      bcc	sr18
    435  fd87		       68		      pla
    436  fd88		       68		      pla
    437  fd89		       8a		      txa		; Save current best movement
    438  fd8a		       48		      pha
    439  fd8b		       98		      tya
    440  fd8c		       48		      pha
    441  fd8d
    442  fd8d		       b5 8c	   sr18       lda	board,x
    443  fd8f		       29 07		      and	#7
    444  fd91		       c9 01		      cmp	#1	; Was it pawn?
    445  fd93		       f0 0c		      beq	sr16	; Yes, end sequence, choose next movement
    446  fd95		       c9 05		      cmp	#5	; Knight or king?
    447  fd97		       b0 08		      bcs	sr16	; End sequence, choose next movement
    448  fd99		       b9 8c 00 	      lda	board,y	; To empty square?
    449  fd9c		       d0 03		      bne	sr16
    450  fd9e		       4c cd fc 	      jmp	sr9	; Yes, follow line of squares
    451  fda1
    452  fda1		       4c 6d fc    sr16       jmp	sr14
    453  fda4
    454  fda4					      if	mode = atari
    455  fda4							;
    456  fda4							; Set object in X
    457  fda4							; A = X position
    458  fda4							; First arg = Object to position (0=P0, 1=P1, 2=M0, 3=M1, 4=BALL)
    459  fda4							; Exits with carry = 0, it can set V flag for X >= 128
    460  fda4							;
    461  fda4					      MAC	set_x_position
    462  fda4					      sta	WSYNC	; 0- Start line synchro
    463  fda4					      sec		; 3- Set carry flag (avoids it in loop)
    464  fda4				   .AE2       sbc	#15	; 5- Uses required time dividing A by 15
    465  fda4					      bcs	.AE2	; 7/8 - 9/14/19/24/29/34/39/44/49/54/59/64
    466  fda4					      tay		; 9
    467  fda4					      lda	fine_adjustment-$f1,y	; 11 - Eats 5 cycles crossing page
    468  fda4					      sta	HMP0+{1}	; 16
    469  fda4					      nop		; 19
    470  fda4					      sta	RESP0+{1}	; 21/26/31/36/41/46/51/56/61/66/71 - "big" positioning
    471  fda4					      ENDM
    472  fda4
    473  fda4							;
    474  fda4							; Display kernel
    475  fda4							;
    476  fda4				   kernel
    477  fda4		       a9 00		      lda	#$00
    478  fda6		       85 09		      sta	COLUBK	; Background color
    479  fda8
    480  fda8							; VERTICAL_SYNC
    481  fda8		       a2 02		      ldx	#2
    482  fdaa		       86 00		      stx	VSYNC	; Start vertical synchro
    483  fdac		       86 02		      stx	WSYNC	; Wait for 3 lines
    484  fdae		       86 02		      stx	WSYNC
    485  fdb0		       86 02		      stx	WSYNC
    486  fdb2							;
    487  fdb2		       a2 2b		      ldx	#43
    488  fdb4		       8e 96 02 	      stx	TIM64T
    489  fdb7		       85 00		      sta	VSYNC	; Stop vertical synchro
    490  fdb9		       85 1b		      sta	GRP0
    491  fdbb		       85 1c		      sta	GRP1
    492  fdbd		       a9 70		      lda	#color_black_square
    493  fdbf		       85 09		      sta	COLUBK	; Background color
    494  fdc1		       a9 35		      lda	#$35
    495  fdc3		       85 04		      sta	NUSIZ0	; Size of player/missile 0
    496  fdc5		       85 05		      sta	NUSIZ1	; Size of player/missile 1
    497  fdc7		       a9 74		      lda	#color_white_square
    498  fdc9		       85 08		      sta	COLUPF	; Color of playfield
    499  fdcb		       a5 87		      lda	cursorx	; Get X-position of cursor and set up missile 0
    500  fdcd		       0a		      asl
    501  fdce		       0a		      asl
    502  fdcf		       85 80		      sta	even
    503  fdd1		       0a		      asl
    504  fdd2		       0a		      asl
    505  fdd3		       65 80		      adc	even	; Can set V flag for eighth square (cursorx = 7)
    506  fdd5		       69 0e		      adc	#14
    507  fdd7		       c9 0e		      cmp	#14
    508  fdd9		       d0 02		      bne	*+4
    509  fddb		       e9 03		      sbc	#3
      0  fddd					      set_x_position	2
      1  fddd		       85 02		      sta	WSYNC
      2  fddf		       38		      sec
      3  fde0		       e9 0f	   .AE2       sbc	#15
      4  fde2		       b0 fc		      bcs	.AE2
      5  fde4		       a8		      tay
      6  fde5		       b9 47 fe 	      lda	fine_adjustment-$f1,y
      7  fde8		       85 22		      sta	HMP0+2
      8  fdea		       ea		      nop
      9  fdeb		       85 12		      sta	RESP0+2
    511  fded		       85 02		      sta	WSYNC
    512  fdef		       85 2a		      sta	HMOVE	; Fine adjustment for all set_x_position
    513  fdf1
    514  fdf1				   wait_vblank
    515  fdf1		       ad 84 02 	      lda	INTIM
    516  fdf4		       d0 fb		      bne	wait_vblank
    517  fdf6							;
    518  fdf6							; Start of graphics
    519  fdf6							;
    520  fdf6		       85 02		      sta	WSYNC
    521  fdf8		       85 01		      sta	VBLANK
    522  fdfa		       85 80		      sta	even	; Now uses like row counter, start at zero
    523  fdfc		       a5 86		      lda	frame	; Board position per frame
    524  fdfe		       29 01		      and	#1
    525  fe00		       0a		      asl
    526  fe01		       aa	   ds0	      tax
    527  fe02		       85 02	   ds1	      sta	WSYNC	; 0 Row 0
    528  fe04		       a5 80		      lda	even	; 3 Squares configuration over board
    529  fe06		       4a		      lsr		; 6
    530  fe07		       90 0a		      bcc	ds6	; 8
    531  fe09		       a9 00		      lda	#$00	; 10
    532  fe0b		       85 0d		      sta	PF0	; 12
    533  fe0d		       a0 7c		      ldy	#$7c	; 15
    534  fe0f		       a9 f8		      lda	#$f8	; 17
    535  fe11		       d0 08		      bne	ds7	; 19
    536  fe13
    537  fe13		       a9 f0	   ds6	      lda	#$f0	; 11
    538  fe15		       85 0d		      sta	PF0	; 13
    539  fe17		       a0 83		      ldy	#$83	; 16
    540  fe19		       a9 07		      lda	#$07	; 18
    541  fe1b		       84 0e	   ds7	      sty	PF1	; 20/22
    542  fe1d		       85 0f		      sta	PF2	; 23/25
    543  fe1f		       b5 8c		      lda	board,x	; 26/28 Bitmap for piece
    544  fe21		       29 07		      and	#7	; 30/34
    545  fe23		       0a		      asl		; 32
    546  fe24		       0a		      asl		; 34
    547  fe25		       0a		      asl		; 36
    548  fe26		       85 82		      sta	bitmap0	; 38
    549  fe28		       b5 8d		      lda	board+1,x	; 41
    550  fe2a		       29 07		      and	#7	; 45
    551  fe2c		       0a		      asl		; 47
    552  fe2d		       0a		      asl		; 49
    553  fe2e		       0a		      asl		; 51 Carry is zero after this instruction
    554  fe2f		       85 83		      sta	bitmap1	; 53
    555  fe31		       85 02		      sta	WSYNC	; 0 Row 1
    556  fe33		       a5 80		      lda	even	; 3 Check if row...
    557  fe35		       c5 88		      cmp	cursory	; 6 ...equals row of cursor
    558  fe37		       08		      php		; 9 Save Z flag...
    559  fe38		       68		      pla		; 12 ...so it goes to bit 1
    560  fe39		       85 1d		      sta	ENAM0	; 16 Enable missile if at right Y position
    561  fe3b		       b5 90		      lda	board+4,x	; 19 Bitmap for piece
    562  fe3d		       29 07		      and	#7	; 23
    563  fe3f		       0a		      asl		; 25
    564  fe40		       0a		      asl		; 27
    565  fe41		       0a		      asl		; 29
    566  fe42		       85 81		      sta	bitmap2	; 31
    567  fe44		       b5 91		      lda	board+5,x	; 34 Bitmap for piece
    568  fe46		       29 07		      and	#7	; 38
    569  fe48		       0a		      asl		; 40
    570  fe49		       0a		      asl		; 42
    571  fe4a		       0a		      asl		; 44
    572  fe4b		       85 8b		      sta	bitmap3	; 46
    573  fe4d		       85 02	   ds3	      sta	WSYNC	; 0
    574  fe4f		       a9 00		      lda	#0	; 3
    575  fe51		       85 1b		      sta	GRP0	; 5
    576  fe53		       85 1c		      sta	GRP1	; 8
    577  fe55		       a5 86		      lda	frame	; 11
    578  fe57		       4a		      lsr		; 14
    579  fe58		       90 3d		      bcc	ds9	; 16
    580  fe5a		       48		      pha
    581  fe5b		       68		      pla
    582  fe5c		       48		      pha
    583  fe5d		       68		      pla
    584  fe5e		       a5 82		      lda	bitmap0
    585  fe60		       85 10		      sta	RESP0	; 35
    586  fe62		       a5 82	   ds11       lda	bitmap0	; 38
    587  fe64		       85 11		      sta	RESP1	; 41
    588  fe66
    589  fe66		       b4 8c		      ldy	board,x	; 44 Check color for first piece
    590  fe68		       b9 ec ff 	      lda	pieces_color,y	; 48
    591  fe6b		       85 06		      sta	COLUP0	; 52
    592  fe6d		       b4 8d		      ldy	board+1,x	; 55 Check color for second piece
    593  fe6f		       b9 ec ff 	      lda	pieces_color,y	; 59
    594  fe72		       85 07		      sta	COLUP1	; 63
    595  fe74		       a4 82		      ldy	bitmap0	; 66
    596  fe76		       b9 00 ff 	      lda	pieces,y	; 69
    597  fe79
    598  fe79		       85 02		      sta	WSYNC
    599  fe7b		       0a		      asl		; 3
    600  fe7c		       85 1b		      sta	GRP0	; 5
    601  fe7e		       a4 83		      ldy	bitmap1	; 8
    602  fe80		       b9 00 ff 	      lda	pieces,y	; 11
    603  fe83		       85 1c		      sta	GRP1	; 15
    604  fe85		       a5 86		      lda	frame
    605  fe87		       4a		      lsr
    606  fe88		       ea		      nop		; 30
    607  fe89		       ea		      nop
    608  fe8a		       b4 90		      ldy	board+4,x	; 35 Check color for third piece (next scanline)
    609  fe8c		       b9 ec ff 	      lda	pieces_color,y	; 39
    610  fe8f		       90 0a		      bcc	ds5	; 28
    611  fe91		       48		      pha
    612  fe92		       68		      pla
    613  fe93		       ea		      nop
    614  fe94		       ea		      nop
    615  fe95		       d0 04		      bne	ds5
    616  fe97
    617  fe97		       85 10	   ds9	      sta	RESP0	; 19
    618  fe99		       90 c7		      bcc	ds11
    619  fe9b
    620  fe9b		       85 06	   ds5	      sta	COLUP0
    621  fe9d		       b4 91		      ldy	board+5,x	; 57 Check color for the two pieces
    622  fe9f		       b9 ec ff 	      lda	pieces_color,y	; 61
    623  fea2		       85 10		      sta	RESP0	; 48
    624  fea4		       85 07		      sta	COLUP1	; 43
    625  fea6		       85 11		      sta	RESP1	; 54
    626  fea8		       a4 81		      ldy	bitmap2	; 3 
    627  feaa
    628  feaa		       85 02		      sta	WSYNC
    629  feac		       b9 00 ff 	      lda	pieces,y	; 6
    630  feaf		       0a		      asl
    631  feb0		       85 1b		      sta	GRP0	; 10
    632  feb2		       a4 8b		      ldy	bitmap3	; 16
    633  feb4		       b9 00 ff 	      lda	pieces,y	; 22
    634  feb7		       85 1c		      sta	GRP1	; 31
    635  feb9		       e6 82		      inc	bitmap0	; 18
    636  febb		       e6 83		      inc	bitmap1	; 23
    637  febd		       e6 81		      inc	bitmap2	; 34
    638  febf		       e6 8b		      inc	bitmap3	; 39
    639  fec1		       98		      tya		; 44
    640  fec2		       29 07		      and	#7	; 47
    641  fec4		       38		      sec		; 26
    642  fec5		       e9 06		      sbc	#6	; 49
    643  fec7		       f0 03		      beq	ds12
    644  fec9		       4c 4d fe 	      jmp	ds3	; 51 + 3
    645  fecc				   ds12
    646  fecc		       85 1d		      sta	ENAM0	; Disable cursor
    647  fece		       e6 80		      inc	even	; Increase current row
    648  fed0		       8a		      txa
    649  fed1		       18		      clc		; Carry is still zero//
    650  fed2		       69 0a		      adc	#10	; Next row of board
    651  fed4		       c9 50		      cmp	#80
    652  fed6		       b0 03		      bcs	ds8
    653  fed8		       4c 01 fe 	      jmp	ds0
    654  fedb				   ds8
    655  fedb
    656  fedb							;
    657  fedb							; End of graphics (204 lines)
    658  fedb							;
    659  fedb		       a9 02		      lda	#2
    660  fedd		       85 02		      sta	WSYNC
    661  fedf		       85 01		      sta	VBLANK
    662  fee1
    663  fee1							;
    664  fee1							; Start overscan timer
    665  fee1							;
    666  fee1		       a9 2b		      lda	#43	; 37 lines * 76 = 2812 cycles / 64 = 43.9375
    667  fee3		       8d 96 02 	      sta	TIM64T
    668  fee6				   wait_overscan
    669  fee6		       ad 84 02 	      lda	INTIM
    670  fee9		       d0 fb		      bne	wait_overscan
    671  feeb		       85 02		      sta	WSYNC
    672  feed		       85 0d		      sta	PF0
    673  feef		       85 0e		      sta	PF1
    674  fef1		       85 0f		      sta	PF2
    675  fef3		       85 02		      sta	WSYNC
    676  fef5		       85 81		      sta	side	; Black side plays
    677  fef7
    678  fef7		       e6 86		      inc	frame
    679  fef9
    680  fef9		       60		      rts
    681  fefa
 Free bytes section 1:  $6
    682  fefa					      echo	"Free bytes section 1: ",$ff00-*
    683  fefa
    684  ff00					      org	$ff00
    685  ff00				   pieces
    686  ff00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00
    687  ff08		       00 18 3c 3c*	      .byte.b	$00,$18,$3c,$3c,$18,$3c,$00,$00
    688  ff10		       5a 7e 3c 3c*	      .byte.b	$5a,$7e,$3c,$3c,$7e,$7e,$00,$00
    689  ff18		       18 3c 3c 3c*	      .byte.b	$18,$3c,$3c,$3c,$18,$66,$00,$00
    690  ff20		       5a 5a 24 3c*	      .byte.b	$5a,$5a,$24,$3c,$3c,$3c,$00,$00
    691  ff28		       70 58 7c 6e*	      .byte.b	$70,$58,$7c,$6e,$1e,$3e,$00,$00
    692  ff30		       3c 6a 56 3c*	      .byte.b	$3c,$6a,$56,$3c,$3c,$3c,$00,$00
    693  ff38
    694  ff38				   fine_adjustment
    695  ff38		       70		      .byte.b	$70	; -7 
    696  ff39		       60		      .byte.b	$60	; -6 
    697  ff3a		       50		      .byte.b	$50	; -5
    698  ff3b		       40		      .byte.b	$40	; -4
    699  ff3c		       30		      .byte.b	$30	; -3
    700  ff3d		       20		      .byte.b	$20	; -2
    701  ff3e		       10		      .byte.b	$10	; -1
    702  ff3f		       00		      .byte.b	$00	; 0
    703  ff40		       f0		      .byte.b	$f0	; +1
    704  ff41		       e0		      .byte.b	$e0	; +2
    705  ff42		       d0		      .byte.b	$d0	; +3
    706  ff43		       c0		      .byte.b	$c0	; +4
    707  ff44		       b0		      .byte.b	$b0	; +5
    708  ff45		       a0		      .byte.b	$a0	; +6
    709  ff46		       90		      .byte.b	$90	; +7
    710  ff47
    711  ff47							;
    712  ff47							; Read a coordinate choosen by cursor
    713  ff47							; Moves y to x, y contains new coordinate.
    714  ff47							;
    715  ff47				   read_coor
    716  ff47		       98		      tya
    717  ff48		       48		      pha
    718  ff49		       20 97 ff 	      jsr	read_coor2
    719  ff4c		       a8		      tay
    720  ff4d		       68		      pla
    721  ff4e		       aa		      tax
    722  ff4f		       60		      rts
    723  ff50
    724  ff50		       a0 00	   rc5	      ldy	#0
    725  ff52		       ad 80 02 	      lda	SWCHA	; Read current state of joystick
    726  ff55		       85 80		      sta	even
    727  ff57		       aa		      tax
    728  ff58		       45 89		      eor	pSWCHA
    729  ff5a		       86 89		      stx	pSWCHA
    730  ff5c		       49 ff		      eor	#$ff
    731  ff5e		       05 80		      ora	even	; Disable unchanged directions
    732  ff60		       30 0a		      bmi	rc0	; Jump if not going right
    733  ff62		       a6 87		      ldx	cursorx
    734  ff64		       e0 07		      cpx	#7
    735  ff66		       f0 04		      beq	rc0
    736  ff68		       e6 87		      inc	cursorx
    737  ff6a		       a0 08		      ldy	#8
    738  ff6c
    739  ff6c		       2a	   rc0	      rol		; Jump if not going left
    740  ff6d		       30 08		      bmi	rc1
    741  ff6f		       a6 87		      ldx	cursorx
    742  ff71		       f0 04		      beq	rc1
    743  ff73		       c6 87		      dec	cursorx
    744  ff75		       a0 08		      ldy	#8
    745  ff77
    746  ff77		       2a	   rc1	      rol		; Jump if not going down
    747  ff78		       30 0a		      bmi	rc2
    748  ff7a		       a6 88		      ldx	cursory
    749  ff7c		       e0 07		      cpx	#7
    750  ff7e		       f0 04		      beq	rc2
    751  ff80		       e6 88		      inc	cursory
    752  ff82		       a0 08		      ldy	#8
    753  ff84
    754  ff84				   rc2
    755  ff84		       2a		      rol		; Jump if not going up
    756  ff85		       30 08		      bmi	rc3
    757  ff87		       a6 88		      ldx	cursory
    758  ff89		       f0 04		      beq	rc3
    759  ff8b		       c6 88		      dec	cursory
    760  ff8d		       a0 08		      ldy	#8
    761  ff8f				   rc3
    762  ff8f		       a2 01		      ldx	#$01
    763  ff91		       86 15		      stx	AUDC0
    764  ff93		       84 19		      sty	AUDV0
    765  ff95		       84 17		      sty	AUDF0
    766  ff97							;	 jmp read_coor2     ; Fall thru
    767  ff97							;
    768  ff97							; Read a coordinate in a
    769  ff97							;
    770  ff97				   read_coor2
    771  ff97		       20 a4 fd 	      jsr	kernel
    772  ff9a							;lda #0	    ; Kernel returns with a = 0
    773  ff9a		       85 19		      sta	AUDV0
    774  ff9c		       a5 0c		      lda	INPT4	; Read current state of button
    775  ff9e		       85 80		      sta	even
    776  ffa0		       aa		      tax
    777  ffa1		       45 8a		      eor	pINPT4
    778  ffa3		       86 8a		      stx	pINPT4
    779  ffa5		       49 ff		      eor	#$ff
    780  ffa7		       05 80		      ora	even	; Disable unchanged button
    781  ffa9		       30 a5		      bmi	rc5	; Jump if button not pressed
    782  ffab							;
    783  ffab							; Computer plays
    784  ffab							;
    785  ffab		       a2 03		      ldx	#$03
    786  ffad		       86 15		      stx	AUDC0
    787  ffaf		       a2 08		      ldx	#$08
    788  ffb1		       86 19		      stx	AUDV0
    789  ffb3		       86 17		      stx	AUDF0
    790  ffb5		       a5 88		      lda	cursory	; y_coor 
    791  ffb7		       0a		      asl		; *2
    792  ffb8		       0a		      asl		; *4
    793  ffb9		       65 88		      adc	cursory	; *5
    794  ffbb		       0a		      asl		; *10
    795  ffbc		       65 87		      adc	cursorx	; + x_coor
    796  ffbe		       60		      rts
    797  ffbf
    798  ffbf				  -	      else
    799  ffbf				  -kernel
    800  ffbf				  -	      jsr	headers
    801  ffbf				  -	      lda	#$38
    802  ffbf				  -	      sta	bitmap0
    803  ffbf				  -	      ldx	#0
    804  ffbf				  -kn0	      lda	bitmap0
    805  ffbf				  -	      sta	$0f
    806  ffbf				  -	      lda	#$20
    807  ffbf				  -	      sta	$0f
    808  ffbf				  -	      ldy	#8
    809  ffbf				  -kn1	      txa
    810  ffbf				  -	      pha
    811  ffbf				  -	      lda	board,x
    812  ffbf				  -	      tax
    813  ffbf				  -	      lda	letters,x
    814  ffbf				  -	      sta	$0f
    815  ffbf				  -	      lda	#$20
    816  ffbf				  -	      sta	$0f
    817  ffbf				  -	      pla
    818  ffbf				  -	      tax
    819  ffbf				  -	      inx
    820  ffbf				  -	      dey
    821  ffbf				  -	      bne	kn1
    822  ffbf				  -	      lda	bitmap0
    823  ffbf				  -	      sta	$0f
    824  ffbf				  -	      lda	#$0a
    825  ffbf				  -	      sta	$0f
    826  ffbf				  -	      dec	bitmap0
    827  ffbf				  -	      inx
    828  ffbf				  -	      inx
    829  ffbf				  -	      cpx	#80
    830  ffbf				  -	      bne	kn0
    831  ffbf				  -	      jsr	headers
    832  ffbf				  -	      rts
    833  ffbf				  -
    834  ffbf				  -headers
    835  ffbf				  -	      ldx	#0
    836  ffbf				  -kn2	      lda	header,x
    837  ffbf				  -	      sta	$0f
    838  ffbf				  -	      lda	#$20
    839  ffbf				  -	      sta	$0f
    840  ffbf				  -	      inx
    841  ffbf				  -	      cpx	#9
    842  ffbf				  -	      bne	kn2
    843  ffbf				  -	      lda	#$0a
    844  ffbf				  -	      sta	$0f
    845  ffbf				  -	      rts
    846  ffbf				  -
    847  ffbf				  -header
    848  ffbf				  -	      .byte	$20,$41,$42,$43,$44,$45,$46,$47
    849  ffbf				  -	      .byte	$48
    850  ffbf				  -
    851  ffbf				  -letters
    852  ffbf				  -	      .byte	$2e,$70,$72,$62,$71,$6e,$6b,$00
    853  ffbf				  -	      .byte	$00,$50,$52,$42,$51,$4e,$4b
    854  ffbf				  -
    855  ffbf				  -			;
    856  ffbf				  -			; Read a coordinate choosen by cursor
    857  ffbf				  -			; Moves y to x, y contains new coordinate.
    858  ffbf				  -			;
    859  ffbf				  -read_coor
    860  ffbf				  -	      tya
    861  ffbf				  -	      tax
    862  ffbf				  -	      jsr	readkey
    863  ffbf				  -	      sta	even
    864  ffbf				  -	      jsr	readkey
    865  ffbf				  -	      eor	#$ff	; 1-8 converted to $fe-$f7
    866  ffbf				  -	      clc
    867  ffbf				  -	      adc	#$09	; row
    868  ffbf				  -	      asl		; x2
    869  ffbf				  -	      sta	bitmap0
    870  ffbf				  -	      asl		; x4
    871  ffbf				  -	      asl		; x8
    872  ffbf				  -	      adc	bitmap0	; x10
    873  ffbf				  -	      adc	even	; +column
    874  ffbf				  -	      tay
    875  ffbf				  -	      dey
    876  ffbf				  -	      rts
    877  ffbf				  -
    878  ffbf				  -readkey
    879  ffbf				  -	      lda	$d011
    880  ffbf				  -	      beq	readkey
    881  ffbf				  -	      lda	$d010
    882  ffbf				  -	      and	#$0f
    883  ffbf				  -	      rts
    884  ffbf				  -
    885  ffbf					      endif
    886  ffbf
    887  ffbf				   initial
    888  ffbf		       02 05 03 04*	      .byte.b	$02,$05,$03,$04,$06,$03,$05,$02
    889  ffc7
    890  ffc7				   scores
    891  ffc7		       00 01 05 03*	      .byte.b	0,1,5,3,9,3
    892  ffcd
    893  ffcd				   offsets
    894  ffcd		       10 14 08 0c*	      .byte.b	16,20,8,12,8,0,8
    895  ffd4
    896  ffd4				   displacement
    897  ffd4		       eb ed f4 f8*	      .byte.b	-21,-19,-12,-8,8,12,19,21
    898  ffdc		       f6 0a ff 01	      .byte.b	-10,10,-1,1
    899  ffe0		       09 0b f7 f5	      .byte.b	9,11,-9,-11
    900  ffe4		       f5 f7 f6 ec	      .byte.b	-11,-9,-10,-20
    901  ffe8		       09 0b 0a 14	      .byte.b	9,11,10,20
    902  ffec
    903  ffec					      if	mode = atari
    904  ffec
    905  ffec				   pieces_color
    906  ffec		       28 28 28 28	      .byte.b	color_black, color_black, color_black, color_black
    907  fff0		       28 28 28 28	      .byte.b	color_black, color_black, color_black, color_black
    908  fff4		       0e 0e 0e 0e	      .byte.b	color_white, color_white, color_white, color_white
    909  fff8		       0e 0e 0e 	      .byte.b	color_white, color_white, color_white
    910  fffb
 Free bytes section 2:  $1
    911  fffb					      echo	"Free bytes section 2: ",$fffc-*
    912  fffb
    913  fffc					      org	$fffc
    914  fffc		       00 fc		      .word.w	START	; RESET
    915  fffe		       00 fc		      .word.w	START	; BRK
    916  10000					       endif
